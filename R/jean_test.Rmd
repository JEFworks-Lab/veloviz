---
title: "Cycle Simulation"
author: "Jean Fan"
date: "9/29/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(uwot)
```

Simulate cells along cycle

```{r jeantest1}
## make circle like cell cycle
par(mfrow=c(1,1))
x <- matrix(rnorm(1000),nc=2)
y <- x/sqrt(rowSums(x^2))
## add some jitter
obs <- t(y)
obs <- jitter(obs, amount = 0.25)
## order points counterclockwise
angle <- atan2(obs[2,], obs[1,])
#angle

## double check quandrants
# angle[obs[2,]>0 & obs[1,]>0]
# angle[obs[2,]>0 & obs[1,]<0]
# angle[obs[2,]<0 & obs[1,]>0]
# angle[obs[2,]<0 & obs[1,]<0]
# 
# angle[obs[2,]<0 & obs[1,]>0] = angle[obs[2,]<0 & obs[1,]>0] + 2*pi
# angle[obs[2,]<0 & obs[1,]<0] = angle[obs[2,]<0 & obs[1,]<0] + 2*pi
# 
# angle[obs[2,]>0 & obs[1,]>0]
# angle[obs[2,]>0 & obs[1,]<0]
# angle[obs[2,]<0 & obs[1,]>0]
# angle[obs[2,]<0 & obs[1,]<0]

obs <- obs[, order(angle)]
#obs
## rainbow
col = colorRampPalette(c(rainbow(10)))(ncol(obs))
labels <- paste0('cell', 1:ncol(obs))
## plot
plot(t(obs),col=col, pch=16)
text(t(obs[,seq(175,225,5)]), labels[seq(175,225,5)])

colnames(obs) <- labels
```


Remove some transient cells

```{r jeantestremove}
cells.keep <- setdiff(labels, paste0('cell', 200:300))
# cells.keep

labels <- labels[which(labels %in% cells.keep)]
obs <- obs[,cells.keep]
plot(t(obs),col=col, pch=16)
text(t(obs[,seq(150,199,by=5)]), labels[seq(150,199,by=5)])
text(t(obs[,seq(200,250,by=7)]), as.character(seq(200,250,by=7))) #labels[seq(200,250,by=7)]

```

Simulate lower dimensional representation of future transcriptional state

```{r jeantest2}
## rotate circle slightly
f = pi*0.1 # adjust as needed
exp = t(obs)
exp[,1] = obs[1,]*cos(f) - obs[2,]*sin(f)
exp[,2] = obs[2,]*cos(f) + obs[1,]*sin(f)
exp = t(exp)

plot(t(obs),col=col, pch=16)
points(t(exp),col=col)
arrows(t(obs)[,1],t(obs)[,2],t(exp)[,1],t(exp)[,2])

colnames(exp) <- labels
```

Try different embeddings

```{r jeantest_veloviz, fig.width=7,fig.height=7}
k = 10
## Lyla's FDG
library(igraph)
library(matie)
library(RANN)
source('../graphViz/projectedNeighbors.R')
set.seed(1)
gsim = graphViz(obs, exp, k, cell.colors=col, similarity_threshold = -1, weighted=TRUE, plot = TRUE, return_graph = TRUE)
#plot(gsim$fdg_coords, main = "FDG: vertex coordinates", col=col, pch=16)
#text(gsim$fdg_coords+0.1, labels = labels)

```

```{r}
g1 = gsim #graph with 0.01 rotation
g2 = gsim #graph with 0.1 rotation
```

```{r, fig.width=9}
par(mfrow = c(1,2))
plot(g1$fdg_coords, main = "FDG: 0.25 jitter, 0.01 pi rotation", col=col, pch=16)
plot(g2$fdg_coords, main = "FDG: 0.25 jitter, 0.1 pi rotation", col=col, pch=16)

#normalize weights 
par(mfrow = c(2,4))
hist(log10(g1$projected_neighbors$dist_comp$invDist), breaks = 500, 
     xlim = c(-1,4), ylim = c(0, 4000), main = "FDG: 0.25 jitter, 0.01 pi rotation \n inverse euclidean")
hist(g1$projected_neighbors$dist_comp$negVectSim, breaks = 500, main = "FDG: 0.25 jitter, 0.01 pi rotation \n negative cosine")
hist(log10(g1$projected_neighbors$all_dists[!is.na(g1$projected_neighbors$all_dists)]), breaks = 500, 
     xlim = c(-6,2), ylim = c(0, 1400), main = "FDG: 0.25 jitter, 0.01 pi rotation \n all composite distances")
hist(log10(abs(g1$projected_neighbors$edge_weights)), breaks = 500, 
     xlim = c(0,4), ylim = c(0, 60),main = "FDG: 0.25 jitter, 0.01 pi rotation \nNN composite dfstances")

hist(log10(g2$projected_neighbors$dist_comp$invDist), breaks = 500, 
     xlim = c(-1,4), ylim = c(0, 4000), main = "FDG: 0.25 jitter, 0.1 pi rotation \n inverse euclidean")
hist(g2$projected_neighbors$dist_comp$negVectSim, breaks = 500, main = "FDG: 0.25 jitter, 0.1 pi rotation \n negative cosine")
hist(log10(g2$projected_neighbors$all_dists), breaks = 500, 
     xlim = c(-6,2), ylim = c(0, 1400), main = "FDG: 0.25 jitter, 0.1 pi rotation \n all composite distances")
hist(log10(abs(g2$projected_neighbors$edge_weights)), breaks = 500, 
     xlim = c(0,4), ylim = c(0, 60), main = "FDG: 0.25 jitter, 0.01 pi rotation \nNN composite dfstances")



```


```{r jeantest_igraphplot, fig.width=8, fig.height=8}
g <- gsim$graph
V(g)$label = NA
V(g)$size = 2
E(g)$arrow.size = 0.5
E(g)$color = rgb(0,0,0,0.1)
plot(g)
```

#Behavior of weights with noise 
```{r, fig.width=10, fig.height=10}
js = c(0.1, 0.25, 0.5, 1) #jitter amounts 
as = c(0.01, 0.05, 0.1, 0.5) #angles to rotate for exp

j01 = list()
ks = c(5,10,50,100)

par(mfrow=c(4,3))
for (j in js){
  ## make circle like cell cycle
  x <- matrix(rnorm(1000),nc=2)
  y <- x/sqrt(rowSums(x^2))
  ## add some jitter
  obs <- t(y)
  obs <- jitter(obs, amount = j)
  ## order points counterclockwise
  angle <- atan2(obs[2,], obs[1,])
  
  obs <- obs[, order(angle)]
  ## rainbow
  col = colorRampPalette(c(rainbow(10)))(ncol(obs))
  labels <- paste0('cell', 1:ncol(obs))
  ## plot
  #plot(t(obs),col=col, pch=16)
  #text(t(obs), labels)
  
  colnames(obs) <- labels
  
  #remove some cells 
  cells.keep <- setdiff(labels, paste0('cell', 200:300))

  labels <- labels[cells.keep]
  obs <- obs[,cells.keep]
  #plot(t(obs),col=col, pch=16)
  
  ## rotate circle slightly
  for (a in as[3]){
    f = pi*a # adjust as needed
    exp = t(obs)
    exp[,1] = obs[1,]*cos(f) - obs[2,]*sin(f)
    exp[,2] = obs[2,]*cos(f) + obs[1,]*sin(f)
    exp = t(exp)
    
    plot(t(obs),col=col, pch=16)
    points(t(exp),col=col)
    arrows(t(obs)[,1],t(obs)[,2],t(exp)[,1],t(exp)[,2])
    
    colnames(exp) <- labels
    #par(mfrow=c(2,4))
    for(k in ks[3]){
      set.seed(1)
      gsim = graphViz(obs, exp, k, cell.colors=col, similarity_threshold = -1, weighted=TRUE, plot = FALSE, return_graph = TRUE)
      j01[[as.character(j)]] = gsim
      plot(gsim$fdg_coords, main = paste0("FDG: vertex coordinates\nJitter:",j,"Angle:",a,"*pi, K:",k), col=col, pch=16)
      
      g <- gsim$graph
      V(g)$label = NA
      V(g)$size = 2
      E(g)$arrow.size = 0.5
      E(g)$color = rgb(0,0,0,0.1)
      plot(g)
    }
    
  }
  
}


```

```{r, fig.width = 7, fig.height=7}

par(mfrow = c(4,2))
for (k in c(1:4)){
  gn = j01[[k]]
  #plot(gn$graph)
  end.edges = E(gn$graph)[.from(c(150:199))]
  end.edges.idx = which(E(gn$graph) %in% end.edges)
  end.edges.wts = E(gn$graph)$weight[end.edges.idx]
  #par(mfrow = c(2,1))
  hist(log10(E(gn$graph)$weight), breaks = 500, main = paste0("All edge weights, jitter:",js[k]), xlim = c(-3,3))
  hist(log10(end.edges.wts), breaks = 100, main = paste0("End edge weights, jitter:",js[k]), xlim = c(-3,3))
  }
```

```{r}
par(mfrow = c(2,2))
for (k in c(1:4)){
  gn = j01[[k]]
  #plot(gn$graph)
  adj.nodes = unlist(adjacent_vertices(gn$graph,c(150:199),mode = "out"))
  hist(adj.nodes, breaks = 500, main = paste0("Adjacent nodes to end nodes, jitter:",js[k]), xlab = "Cell Index", xlim = c(150,350), ylim = c(0,50))
  }


```


```{r fig.width = 7, fig.height=7}
par(mfrow = c(4,3))
for (k in c(1:4)){
  gn = j01[[k]]
  
  knn = gn$projected_neighbors$kNNs
  inv.euc = gn$projected_neighbors$dist_comp$invDist
  neg.sim = gn$projected_neighbors$dist_comp$negVectSim
  all.dists = gn$projected_neighbors$all_dists
  all.dists = max(all.dists,na.rm = TRUE) - all.dists
  
  hist(log10(inv.euc), breaks = 500, main = paste0("All inverse euclidean, jitter:",js[k]), xlim = c(-0.5,3), ylim = c(0,4000))
  hist(neg.sim, breaks = 500, main = paste0("All negative similarity, jitter:",js[k]), xlim = c(-1,1), ylim = c(0,5500))
  hist(log10(all.dists), breaks = 500, main = paste0("All composite dists, jitter:",js[k]))#, xlim = c(-0.5,3), ylim = c(0,4000))
  
  }

par(mfrow = c(4,2))
for (k in c(1:4)){
  gn = j01[[k]]
  
  knn = gn$projected_neighbors$kNNs
  inv.euc = gn$projected_neighbors$dist_comp$invDist
  neg.sim = gn$projected_neighbors$dist_comp$negVectSim
  inv.euc.keep = t(sapply(c(1:399), function(x) inv.euc[x,knn[x,]]))
  neg.sim.keep = t(sapply(c(1:399), function(x) neg.sim[x,knn[x,]]))
  
  hist(log10(inv.euc.keep), breaks = 500, main = paste0("Inverse euclidean, jitter:",js[k]), xlim = c(-0.5,3), ylim = c(0,200))
  hist(neg.sim.keep, breaks = 500, main = paste0("Negative similarity, jitter:",js[k]), xlim = c(-1,-0.1), ylim = c(0,3500))
  }


```



```{r, fig.width=10, fig.height=10}
#look at jitter =0.01, increasing angle 

par(mfrow = c(4,4))
for(g in c(1:4)){
  curr.graph = j01[[g]]
  curr.angle = as[g]
  hist(log10(curr.graph$projected_neighbors$dist_comp$invDist), breaks = 500, 
       xlim = c(-1,4), ylim = c(0, 4000), main = paste("FDG: 0.01 jitter,",curr.angle,"* pi rotation \n inverse euclidean"))
  hist(curr.graph$projected_neighbors$dist_comp$negVectSim, breaks = 500, 
       ylim = c(0, 12000), main = paste("FDG: 0.01 jitter,",curr.angle,"* pi rotation \n negative cosine"))
  hist(log10(curr.graph$projected_neighbors$all_dists[!is.na(g1$projected_neighbors$all_dists)]), breaks = 500, 
       xlim = c(-6,2), ylim = c(0, 1400), main = paste("FDG: 0.01 jitter,",curr.angle,"* pi rotation \n all composite distances"))
  hist(log10(E(curr.graph$graph)$weight), breaks = 500, ylim = c(0,110), xlim = c(-3,4),
       main = paste("FDG: 0.01 jitter,",curr.angle,"* pi rotation \nNN composite distances"))
  #hist(log10(abs(curr.graph$projected_neighbors$edge_weights)), breaks = 500, 
  #     xlim = c(0,4), ylim = c(0, 70),main = paste("FDG: 0.01 jitter,",curr.angle,"* pi rotation \nNN composite distances"))
    
  
}





```



```{r}

```









```{r jeantest_pca}
## PCA
test <- prcomp(t(obs), scale=TRUE, center=TRUE)
test <- test$x
plot(test, main = "pca", col=col, pch=16)
#text(test+0.1, labels=labels)
```

```{r jeantest_umap}
## Umap
test <- uwot::umap(t(obs), n_neighbors = k, min=0.1)
plot(test, main = "umap", col=col, pch=16)
#text(test+0.1, labels=labels)
```

```{r jeantest_tsne}
## tSNE
test <- Rtsne::Rtsne(t(obs), perplexity=k)$Y
plot(test, main = "tsne", col=col, pch=16)
#text(test+0.1, labels=labels)
```

```{r jeantest_dm}
## diffusion map
test <- destiny::DiffusionMap(t(obs))
test <- test@eigenvectors[,1:2]
plot(test, main = "Diffusion Map", col=col, pch=16)
#text(test+0.1, labels=labels)
```

```{r jeantest_fdg}
## Regular FDG on observed only
nn = RANN::nn2(t(obs), k = k) ## KNN
names(nn) <- c('idx', 'dists')
weight <- 1/(1+ as.vector(nn$dists))
nn.df = data.frame(from = rep(1:nrow(nn$idx), k),
                   to = as.vector(nn$idx),
                   weight = weight
)
g <- igraph::graph_from_data_frame(nn.df, directed = FALSE)
g <- igraph::simplify(g)
fdg = layout_with_fr(g,dim=2)
colnames(fdg) = c("C1","C2")
rownames(fdg) <- labels
plot(fdg, main = "simple fdg", col=col, pch=16)
#text(fdg+0.1, labels = labels)
```
