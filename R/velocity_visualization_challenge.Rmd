---
title: "Velocity Visualization Challenge"
author: "Jean Fan"
date: "7/30/2020"
output: pdf_document
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(
    warning = FALSE,
    message = FALSE,
    cache = FALSE,
    dpi=100
)
```

# Introduction

In this tutorial, we will explore some of the challenges with visualizing RNA velocity results by walking through an RNA velocity analysis using MERFISH data of U2OS cells from Xia\*, Fan\*, Emanuel\*, et al PNAS 2019. 

# Read in data

We will first read in expression count matrices for the whole cell and the nucleus respectively provided as Supplementary Tables 12 and 14. We will also create a cytoplasmic expression count matrix by subtracting the nucleus from the whole cell for downstream use. Here, each row is a gene (or blank) assayed by MERFISH, and each column is a cell. 

```{r data}
dir <- '../data/'
cell_gexp <- as.matrix(read.csv(paste0(dir, 'S12_cell_gexp.csv'), row.names=1))
print(cell_gexp[1:5,1:5])
nuc_gexp <- as.matrix(read.csv(paste0(dir, 'S14_nuc_gexp.csv'), row.names=1))
print(nuc_gexp[1:5,1:5])
cyto_gexp <- cell_gexp - nuc_gexp
print(cyto_gexp[1:5,1:5])
```

In this MERFISH library, 9,050 genes that were labeled with the non-overlapping encoding probe strategy (rows 2 to 9,051) and the 1,000 genes were labeled with the overlapping encoding probe strategy (rows 9,280 to 10,279). The remaining are used a blank controls. We will limit our analysis to just the non-overlapping encoding probe strategy genes (ie. long genes) as the authors did in the original paper.

```{r genetypes}
gene_info <- read.csv(paste0(dir, 'S1_codebook.csv'), header=FALSE, stringsAsFactors = FALSE)
long.genes <- gene_info[2:9051,1]
short.genes <- gene_info[9280:10279,1]
bad.genes <- gene_info[,1][grepl('Blank', gene_info[,1])]

length(long.genes)
length(short.genes)
length(bad.genes)

test.genes <- long.genes ## use subset of genes as in original paper
cell_gexp <- cell_gexp[test.genes,]
nuc_gexp <- nuc_gexp[test.genes,]
cyto_gexp <- cyto_gexp[test.genes,]
```

# Cluster cells

Single-cell transcriptomic analysis enables the identification of novel cell types and cell states in a systematic and quantitative manner. To illustrate this, we will perform single-cell clustering analysis to identify cell populations based on the gene expression profiles of individual cells. Briefly, we filter out lowly expressed genes, performed batch correction, CPM and variance normalization, identify over-dispersed genes, and applied principal components (PC) analysis to identify 30 PCs that capture the greatest variance, and apply graph-based Louvain clustering in the PC space to identify cell clusters.

```{r cluster, fig.height = 6, fig.width = 6}
cd <- cell_gexp

## annotate batch
batch <- sapply(colnames(cd), function(x) strsplit(x, '_')[[1]][1])
batch <- factor(batch)
table(batch)

## remove lowly expressed
vi <- rowMeans(cd) > 1
table(vi)
cd <- cd[vi,]

## batch correct (simply with ComBat here since no cell-type heterogeneity; otherwise recommend Harmony)
library(sva)
mat.bc <- ComBat(as.matrix(cd), batch[colnames(cd)])
mat.bc[mat.bc < 0] <- 0
mat <- mat.bc

## Use this helper package for some normalizations
library(MUDAN)
## CPM normalization
matcpm <- normalizeCounts(mat)
## Variance normalization
matnorm <- MUDAN::normalizeVariance(matcpm, details=TRUE, plot=TRUE)
## Restrict to overdispersed genes
m <- log10(as.matrix(t(matnorm$mat[matnorm$ods,]))+1)

## PCA (slow)
#pcs <- prcomp(m)
## PCA (fast)
pca <- RSpectra::svds(
  A    = m,
  k    = 50,
  opts = list(
    center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10
  )
)

## look at elbow plot to check what is reasonable number of pcs
val <- pca$d
plot(val, type="l")
points(val)
N <- 30
abline(v=N, col='red')
pcs <- pca$u[, 1:N]
rownames(pcs) <- colnames(mat)
colnames(pcs) <- paste0('PC', 1:N)
head(pcs)

## use first two PCs as lower dimensional embedding
emb.test <- pcs[,1:2]

## Graph based community detection
com <- MUDAN::getComMembership(pcs, 
                               k=300, 
                               method = igraph::cluster_louvain)

## Plot
par(mfrow=c(1,2), mar=rep(5,4))
MUDAN::plotEmbedding(emb.test, groups=com, 
              mark.clusters=TRUE, show.legend=TRUE, 
              xlab='PC1', ylab='PC2', main='clustering', 
              verbose=FALSE)
MUDAN::plotEmbedding(emb.test, groups=batch, show.legend=TRUE, 
              xlab='PC1', ylab='PC2', main='batch', 
              verbose=FALSE)
```

Given that our measurements were performed on a single cell type, we previously noted these clusters to likely represent distinct cell states at different stages of the cell cycle. We can visualize expression of known cell-cycle markers to confirm this hypothesis. For example, MCM5 is an early G1 gene whereas KIF2C is an M-phase gene. PPIE is a house-keeping gene not related to cell-cycle. 

```{r cc, fig.height = 6, fig.width = 6}
## Plot cell-cycle and house keeping genes noted in the manuscript
par(mfrow=c(3,3), mar=rep(1,4))
gs <- c('MCM5','SNN','UNG','MCM6','DSCC1','BCL2L1','CCNF','KIF2C','PPIE')
invisible(lapply(gs, function(g) {
    gexp = scale(log10(matcpm[g,]+1))[,1]
    gexp[gexp > 2] <- 2
    gexp[gexp < -2] <- -2
    MUDAN::plotEmbedding(emb.test, main=g, col=gexp, verbose=FALSE)
}))
```

# Derive velocity model

Further understanding of these cell states will benefit from quantification of temporal changes of gene expression profiles across the cell cycle. However, like scRNA-seq analysis, MERFISH measurements capture only static snapshots in time. To address this limitation, we sought to place cells on a pseudotime axis by analysis of the RNA velocity, i.e. the time derivative of the gene expression state. As detailed in the original manuscript, we reasoned that RNA velocity could be inferred by distinguishing between nuclear and cytoplasmic mRNAs, leveraging the spatial information of transcripts obtained in our MERFISH measurements. We use these nuclear and cytoplasmic expression measurements as in situ analogues of unspliced and spliced mRNA expression measurements used in the original RNA velocity manuscript (La Manno et al, Nature 2018). Due to concerns of batch effects, we will limit analysis to one batch. 

```{r velocity}
library(velocyto.R)

## Color by cluster
cluster.label <- factor(com)
cell.colors <- MUDAN:::fac2col(cluster.label)

## Can limit to one batch of cells
#subcells <- names(batch)[batch == 'B2']
## Or use all cells
subcells <- names(batch)
emat <- cyto_gexp[, subcells] 
nmat <- nuc_gexp[, subcells] 
cell.dist <- as.dist(1-cor(t(pcs[subcells,]))) ## cell distance in PC space
fit.quantile <- 0.05 ## 5th extreme quantile
## Velocity model
rvel.cd <- gene.relative.velocity.estimates(emat, nmat, 
                                            deltaT=1, kCells=30, 
                                            cell.dist=cell.dist,
                                            fit.quantile=fit.quantile)
```

Upon active upregulation of a gene, we anticipate a rapid increase in nuclear mRNA counts, followed by an increase in cytoplasmic mRNA counts due to nuclear export until a new steady state is reached. Conversely, active downregulation in transcription would lead to a rapid reduction in nuclear mRNA counts as the nuclear export of mRNAs continues; the cytoplasmic mRNA will drop eventually because of the reduction in the nuclear RNA pool for export and the continued RNA degradation in the cytoplasm. We can plot a few example cell-cycle genes to see if this assumption holds in our data for the appropriate clusters. 

```{r velocity-example, fig.height = 2, fig.width = 6}
## Plot a few genes
gene.relative.velocity.estimates(emat, nmat,
                                 kCells = 30,
                                 fit.quantile = fit.quantile,
                                 old.fit=rvel.cd,
                                 show.gene='KIF2C',
                                 cell.emb=emb.test,
                                 cell.colors=cell.colors)
```

# Visualize velocity 

The balance of nuclear and cytoplasmic mRNA abundance is, therefore, an indicator of the future state of cytoplasmic RNA abundance. We used this approach to determine the RNA velocity for each cell and projected these velocities as arrows. In this case, the RNA velocity arrows nicely recapitulate our expected cell cycle process.  

```{r velocity-plots, fig.height = 6, fig.width = 6}
## Plot on PCs
show.velocity.on.embedding.cor(scale(emb.test), rvel.cd, n=100,
                               scale='sqrt', cell.colors=cell.colors,
                               cex=1, arrow.scale=1, show.grid.flow=TRUE, 
                               min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)
```

However, RNA velocities can be visualized on a variety of low dimensional embeddings. Unfortunately, depending on how well these lower dimensional embeddings capture the underlying cellular transcriptional dynamics, we may end up with very different visual impressions. Let's try visuallizing RNA velocities on a few different embeddings to see what we mean. 

```{r velocity-tsne, fig.height = 6, fig.width = 6}
## tSNE 
set.seed(1)
library(Rtsne)
emb.tsne <- Rtsne::Rtsne(pcs, 
                    is_distance=FALSE,
                    perplexity=10,
                    num_threads=1,
                    verbose=FALSE)$Y
rownames(emb.tsne) <- rownames(pcs)

show.velocity.on.embedding.cor(scale(emb.tsne), rvel.cd, n=100,
                               scale='sqrt', cell.colors=cell.colors,
                               cex=1, arrow.scale=1, show.grid.flow=TRUE, 
                               min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)
```

```{r velocity-destiny, fig.height = 6, fig.width = 6}
## diffusion mapping on 30 PCs
library(destiny)
emb.destiny <- destiny::DiffusionMap(pcs)
emb.destiny <- eigenvectors(emb.destiny)[,1:2]

show.velocity.on.embedding.cor(scale(emb.destiny), rvel.cd, n=100,
                               scale='sqrt', cell.colors=cell.colors,
                               cex=1, arrow.scale=1, show.grid.flow=TRUE, 
                               min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)
```

# Try it out for yourself

1. Use `UMAP` to derive a lower dimensional embedding that is more faithful to long-range relationships between cells. Does this help? What is you change `UMAP` parameters?
2. Create a new approach to derive the lower dimensional embedding directly from RNA velocity estimates using force directed graphs. For each cell, use the RNA velocity model to predict the future transcriptional state. For each cell, identify the k-nearest neighbor of this predicted future transcriptional state and the currently observed cells (excluding the cell itself). Create a graph to represent this relationship and visualize the graph using forced-directed embedding. 
