---
title: "Adding edge weights"
author: "LylaAtta"
date: "9/18/2020"
output: html_document
---

Here, we want to add edge weights to our graph embedding and see how that affects visualizations.  


#### Setup and get data from scVelo
```{r setup, include=FALSE}
#using velocyto2 evironment 
knitr::opts_chunk$set(echo = FALSE)
library(reticulate)
library(igraph)
library(matie)
library(RANN)
library(velocyto.R)
library(MUDAN)
library(RSpectra)
library(umap)
source("projectedNeighbors.R")
```

Use the reticulate package to use scVelo from within R:   
```{r importing scvelo}
use_condaenv("velo",required = TRUE)
scv = import("scvelo")
#scv$logging$print_version()
```

```{r loading panc data, message=FALSE}
adata = scv$datasets$pancreas()
#scv$pl$scatter(adata,legend_loc = "lower left", size = 60)

emb_umap = adata$obsm['X_umap'] #extract umap embedding 
clusters = adata$obs$clusters #extract clusters 
rownames(emb_umap) = names(clusters) = adata$obs_names$values

col = rainbow(length(levels(clusters)),s = 0.8, v = 0.8) 
cell.cols = col[clusters] #color according to cluster
names(cell.cols) = names(clusters)
```

```{r plot panc data on umap, included = FALSE}
plot(emb_umap, col = cell.cols, pch=16, xlab = "UMAP X", ylab = "UMAP Y", xlim = c(-15,20))
legend(x=10, y=6, legend = levels(clusters), col = col, pch = 16)
```

#### Make fdg embedding 

Extract count data..  
```{r extract counts, message = FALSE, results='hide', included = FALSE}
spliced = as.matrix(t(adata$layers['spliced']))
unspliced = as.matrix(t(adata$layers['unspliced']))
cells = adata$obs_names$values
genes = adata$var_names$values
colnames(spliced) = colnames(unspliced) = cells
rownames(spliced) = rownames(unspliced) = genes
```

Filter genes  
```{r filter genes, message = FALSE , included = FALSE}
gexpS = log10(rowSums(spliced)+1)
gexpU = log10(rowSums(unspliced)+2)
#plot(gexpS,gexpU)
goodGenes = genes[gexpS > 2 & gexpU > 1]
spliced = spliced[goodGenes,]
unspliced = unspliced[goodGenes,]
```

Downsample cells to make things easier  
```{r downsample, results='hide', included = FALSE}
spliced.sub = spliced[,seq(1,ncol(spliced),by=3)]
cell.names.pca = colnames(spliced.sub)
unspliced.sub = unspliced[,seq(1,ncol(unspliced),by=3)]
#cell.dist.sub = as.dist(1-cor(t(pcs[seq(1,ncol(unspliced),by=3),])))
cell.cols.sub = cell.cols[colnames(spliced.sub)]
```

Normalize for dimensional reduction  
```{r normalize, results='hide', included = FALSE}
allExp = spliced.sub + unspliced.sub #use combined spliced and unspliced counts 
all.cpm = MUDAN::normalizeCounts(allExp) #cpm normalize
all.norm = MUDAN::normalizeVariance(all.cpm,details = TRUE, plot = FALSE) #variance stabilize 
odsGenes = goodGenes[all.norm$ods] #overdispersed genes
all.logODS = log10(as.matrix(t(all.norm$mat[all.norm$ods,]))+1) #keep overdispersed genes and log normalize
```

Dimensional reduction  
```{r dimensional reduction, included = FALSE}
pca = svds(A = all.logODS, k=50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var = pca$d
#plot(var) # ~5 components 

emb.pca = pca$u[,1:2]
row.names(emb.pca) = row.names(all.logODS)
plot(emb.pca, col = cell.cols.sub, pch = 16, xlab = "PC1", ylab = "PC2", main = "PCA on subsampled data")

```


Run velocyto on panc data  
```{r velocity, message = FALSE, results = 'hide', included = FALSE}
#vel = gene.relative.velocity.estimates(spliced.sub,unspliced.sub,deltaT=1,kCells=30,cell.dist=cell.dist.sub,fit.quantile=0.1,mult=100)
#saveRDS(vel,file = "panc_vel.rds")
vel = readRDS("./saved_objects/panc_vel.rds")
curr = vel$current
proj = vel$projected

#show velocity on PCA
show.velocity.on.embedding.cor(scale(emb.pca), vel, n=100, scale='sqrt', cell.colors=cell.cols.sub,cex=1, arrow.scale=1, show.grid.flow=TRUE,min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2, main = "Velocities on PCA embedding")

# #show velocity on UMAP 
# emb.umap.sub = emb_umap[rownames(emb.pca),]
# show.velocity.on.embedding.cor(scale(emb.umap.sub), vel, n=100, scale='sqrt', cell.colors=cell.cols.sub,cex=1, arrow.scale=1, show.grid.flow=TRUE,min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2, main = "Velocities on UMAP embedding")

```  


Scores of observed and projected states in PC space  
```{r pc scores, included = FALSE}
u = pca$u #scores
v = pca$v #loads
row.names(v) = odsGenes

common.genes = sapply(row.names(curr), function(x) x %in% odsGenes)
common.genes.names = rownames(curr)[common.genes]
curr.pca = curr[common.genes,]
v.sub = v[row.names(curr.pca),]

par(mfrow = c(1,2))

curr.scores = t(curr.pca) %*% v.sub
plot(curr.scores[,1:2], col = cell.cols.sub, main = 'Observed',xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))

proj.pca = proj[common.genes,]
proj.scores = t(proj.pca) %*% v.sub
plot(proj.scores[,1:2], col = cell.cols.sub, main = 'Projected',xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))

```

Graph visualization on subset of cells from PC coordinates  
```{r graph viz from PCs, results = "hide"}
set.seed(1)
cell.names = colnames(curr)
cell.names.sub = cell.names[seq(1,length(cell.names),5)] #downsample cells for speed 
ncells.sub = length(cell.names.sub)
cell.cols.grph = cell.cols[cell.names.sub]

curr.scores.cellsub = t(curr.scores[cell.names.sub,]) #### change here to change number of PCs included 
proj.scores.cellsub = t(proj.scores[cell.names.sub,]) ####

```


#### Adding edge weights 
Here, I'm using the composite distances as edge weights.  
Negative edge weights messes with the graph layout. In this case, because our similarity is 0.25, all of our composite distances are negative. So I took just took the abs value of composite distances. Probably need to figure out a better way to deal with negative edge weights...  
```{r adding edge weights, results = "hide"}
set.seed(1)
g = graphViz(curr.scores.cellsub, proj.scores.cellsub, k=10, distance_metric="L2", similarity_metric="cosine", similarity_threshold=0.25, weighted = FALSE, cell.colors = cell.cols.grph, title = "Without Edge Weights", plot = TRUE, return_graph = TRUE)
set.seed(1)
g = graphViz(curr.scores.cellsub, proj.scores.cellsub, k=10, distance_metric="L2", similarity_metric="cosine", similarity_threshold=0.25, weighted = TRUE, cell.colors = cell.cols.grph, title = "With Edge Weights", plot = TRUE, return_graph = TRUE)




```


Distribution of pairwise composite distance amongst all k nearest neighbors:  
```{r edge weight distribution}
e = g$projected_neighbors$edge_weights
hist(e,breaks = 500)
```


#### Compare consistency scores 
```{r calculating consistency scores, results = 'hide'}
set.seed(1)
coords_noWts = graphViz(curr.scores.cellsub, proj.scores.cellsub, k=10, distance_metric="L2", similarity_metric="cosine", similarity_threshold=0.25, weighted = FALSE, cell.colors = cell.cols.grph, title = "Without Edge Weights", plot = FALSE, return_graph = TRUE)$fdg_coords
set.seed(1)
coords_wts = graphViz(curr.scores.cellsub, proj.scores.cellsub, k=10, distance_metric="L2", similarity_metric="cosine", similarity_threshold=0.25, weighted = TRUE, cell.colors = cell.cols.grph, title = "With Edge Weights", plot = FALSE, return_graph = TRUE)$fdg_coords

deltaExp = vel$deltaE[,cell.names.sub]
scores_noWts = consistency(coords_noWts,deltaExp,20,FALSE)
scores_wts = consistency(coords_wts,deltaExp,20,FALSE)


```


```{r comparing consistency scores,fig.width = 6,fig.height=6}
par(mfrow = c(2,1))
x = c(-0.2,1)
y = c(0,12)
xt = "Cell Consistency Score"
hist(scores_noWts,breaks = 100,xlim = x, ylim = y, col = "red", xlab =  xt, main = "No edge weights")
text(x = c(0.1,0.1),y = c(10,8),c(paste("Mean:",as.character(mean(scores_noWts))),paste("Median:",as.character(median(scores_noWts)))))
hist(scores_wts,breaks = 100, col = "blue",xlim = x, ylim = y,xlab =  xt, main = "Edge weights")
text(x = c(0.1,0.1),y = c(10,8),c(paste("Mean:",as.character(mean(scores_wts))),paste("Median:",as.character(median(scores_wts)))))

```





