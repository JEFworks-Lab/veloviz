---
title: "graphViz U2O5"
author: "LylaAtta"
date: "8/19/2020"
output:
  html_document: default
  pdf_document: default
---
#### Setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,include = FALSE)
library(igraph)
library(matie)
library(RANN)
library(velocyto.R)
rvel.cd = readRDS("rvelcd.rds")
emb.test = readRDS("embTest.rds")
cell.color = readRDS("cellColor.rds")
pcaInfo = readRDS("pcaInfo.rds")

curr = rvel.cd$current #observed cells 
proj = rvel.cd$projected #projected states
```

RNA velocity (steady state model) projected on PCA embedding. 
```{r, results='hide', include=TRUE}
show.velocity.on.embedding.cor(scale(emb.test), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)
```

#### Constructing embedding from velocity projections
For each observed cell_i, find the nearest neighbor, cell_{nn,i}, to it's projected state p_i in the observed cells excluding cell_i. Build a force directed graph where edges are pointing from cell_i to cell_{nn,i}. 
Find neighbors, calculate edge weights  
```{r euclidean dist neighbors}
curr = rvel.cd$current #observed cells 
proj = rvel.cd$projected #projected states

ncells = ncol(curr)
cellidx = sapply(seq(1:ncells), function(x) nn2(t(curr[,-x]),t(proj[,x]),k=1)$nn.idx) #index of cell_{nn,i}
celldist = sapply(seq(1:ncells), function(x) nn2(t(curr[,-x]),t(proj[,x]),k=1)$nn.dist) #distance between p_i and cell_{nn,i}


for (c in seq(1,length(cellidx))){
  if (cellidx[c]>=c){
    cellidx[c] = cellidx[c] + 1
  }
}

edgeList = cbind(seq(1,ncells),cellidx)
edgeWeights = 1/(1+celldist)
```

G0: force directed graph with no edge weights 
```{r G0, results='hide', fig.width=2, fig.height=2}
g0 = graph_from_edgelist(edgeList,directed =TRUE)
g0FD = layout_with_fr(g0)
colnames(g0FD) = c("C1","C2")
rownames(g0FD) = colnames(curr)

show.velocity.on.embedding.cor(scale(g0FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)
```

G1: force directed graph with edge weights 
```{r G1, eval = FALSE, fig.width=2, fig.height=2}
g1 = graph_from_edgelist(edgeList, directed = TRUE)
edge.attributes(g1)$weight = edgeWeights
g1FD = layout_with_fr(g1)
colnames(g1FD) = c("C1","C2")
rownames(g1FD) = colnames(curr)

show.velocity.on.embedding.cor(scale(g1FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)
```

G2: force directed graph with no edge weights, starting with pca coords
```{r G2, eval = FALSE, fig.width=2, fig.height=2}
g2 = graph_from_edgelist(edgeList,directed =TRUE)
g2FD = layout_with_fr(g2,emb.test)
colnames(g2FD) = c("C1","C2")
rownames(g2FD) = colnames(curr)

show.velocity.on.embedding.cor(scale(g2FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)
```

G3: force directed graph with edge weights, starting with pca coords 
```{r G3, eval = FALSE, fig.width=2, fig.height=2}
g3 = graph_from_edgelist(edgeList, directed = TRUE)
edge.attributes(g3)$weight = edgeWeights
g3FD = layout_with_fr(g3,emb.test)
colnames(g3FD) = c("C1","C2")
rownames(g3FD) = colnames(curr)

show.velocity.on.embedding.cor(scale(g3FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)
```

#### Subsample U2O5 data and construct graph from subset:
Try on subset of the data to see what's happening. Want to sample cells across expression space (across cell cycles states) but not sure what order they're in in the data - order by angle from vertical in PC1vPC2 space and then uniform sample: 
```{r subsample, results = 'hide', include=TRUE, fig.width=3, fig.height=3}
pcaAngle = acos(emb.test[,2]/sqrt(emb.test[,1]^2 + emb.test[,2]^2))
pcaAngleOrd = order(pcaAngle)
pcaAngle = pcaAngle[pcaAngleOrd]
emb.test.ord = emb.test[pcaAngleOrd,]
emb.test.sub.names = rownames(emb.test.ord)[seq(1,1368,by=5)] #### CHANGE HERE to change size of sample
emb.test.sub = emb.test.ord[emb.test.sub.names,]
cell.color.sub = cell.color[emb.test.sub.names]
plot(emb.test.sub, col = cell.color.sub, pch = 16)

show.velocity.on.embedding.cor(scale(emb.test.sub), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2, return.details = TRUE)

curr.sub = curr[,emb.test.sub.names]
proj.sub = proj[,emb.test.sub.names]

ncells.sub = ncol(curr.sub)

```

Make graph for sample subset: 
```{r subsample graph, include=FALSE}
cellidx.sub = sapply(seq(1:ncells.sub), function(x) nn2(t(curr.sub[,-x]),t(proj.sub[,x]),k=1)$nn.idx) #index of cell_{nn,i}
celldist.sub = sapply(seq(1:ncells.sub), function(x) nn2(t(curr.sub[,-x]),t(proj.sub[,x]),k=1)$nn.dist) #distance between p_i and cell_{nn,i}


for (c in seq(1,length(cellidx.sub))){
  if (cellidx.sub[c]>=c){
    cellidx.sub[c] = cellidx.sub[c] + 1
  }
}

edgeList.sub = cbind(seq(1,ncells.sub),cellidx.sub)
edgeWeights.sub = 1/(1+celldist.sub)
```

G4: force directed graph with no edge weights on subsample 
```{r G4, eval = FALSE, fig.width=3, fig.height=3}
g4 = graph_from_edgelist(edgeList.sub,directed =TRUE)
V(g4)$color = cell.color.sub 
plot(g4)
g4FD = layout_with_fr(g4)
colnames(g4FD) = c("C1","C2")
rownames(g4FD) = colnames(curr.sub)

show.velocity.on.embedding.cor(scale(g4FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)
text(scale(g4FD)+0.1,labels = seq(1,dim(g4FD)[1]))
```

G5: force directed graph with no edge weights on subsample 
```{r G5, eval = FALSE}
g5 = graph_from_edgelist(edgeList.sub,directed =TRUE)
V(g5)$color = cell.color.sub 
edge.attributes(g5)$weight = edgeWeights.sub
plot(g5)
g5FD = layout_with_fr(g5)
colnames(g5FD) = c("C1","C2")
rownames(g5FD) = colnames(curr.sub)

show.velocity.on.embedding.cor(scale(g5FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)
text(scale(g5FD)+0.1,labels = seq(1,dim(g4FD)[1]))
```

This method likely results in some identified neighbors being "behind" the cell of interest, especially if the velocity vector is small. --> Make new projected nearest neighbor function that takes into account the direction from cell_i to the nearest neighbor as compared to the direction of the velocity vector. We're interested in neighbors where cell_i-->nn_i is in a similar direction to the velocity vector i.e. cell_i-->proj_i. 

#### New distance function 
In addition to minimizing distance between the projected state and the nearest neighbor, we also want to maximize similarity between the direction of the velocity vector and the vector between cell_i and its nearest neighbor. Combining them into one quantity to be minimized: -ve similarity * 1/distance. (Inverting the distance since the negative sign makes farther cells have a smaller quantity (more negative) than closer cells). For distance, we can use L1 norm (`distance_metric="L1"`) or L2 norm (`distance_metric="L2"`). For similarity, we can use cosine similarity (`similarity_metric="cosine"`) or pearson correlation (`similarity_metric="pearson"`). 
```{r new dist function}
myDist = function(cell_i,proj_i,nn_i,distance_metric="L2",similarity_metric="cosine"){
  #cell_i: current cell
  #proj_i: projected state of cell i based on velocity
  #nn_i: putative nearest neighbor to cell_i 
  #distance_metric: "L1" or "L2" 
  #similarity_metric" "cosine" or "pearson" 
  
  #distance to minimize is between proj_i and nn_i: d = nn_i - proj_i 
  #angle to minimize is between velocity (v = proj_i - cell_i) and cell_i --> nn_i (n = nn_i - cell_i)
  
  d = nn_i - proj_i
  v = proj_i - cell_i 
  n = nn_i - cell_i 
  
  #distance  
  if (distance_metric=="L2"){
    invDist = 1/stats::dist(rbind(nn_i,proj_i),method = "euclidean")
    #print(paste("invL2",invDist))
  } else if (distance_metric=="L1"){
    invDist = 1/stats::dist(rbind(nn_i,proj_i),method = "manhattan")
    #print(paste("invL1",invDist))
  }
  
  # invEuc = 1/sqrt(sum(d^2))
  # print(paste("invEuc",invEuc))
  # invL2 = 1/stats::dist(rbind(nn_i,proj_i),method = "euclidean")
  # print(paste("invL2",invL2))
  # invL1 = 1/stats::dist(rbind(nn_i,proj_i),method = "manhattan")
  # print(paste("invL1",invL1))
  
  #vector similarity 
  if (similarity_metric=="cosine"){
    negVectSim = -1*(v %*% n)/(sqrt(sum(v^2))*sqrt(sum(n^2))) 
    #print(paste("negCos",negVectSim))
  } else if (similarity_metric=="pearson"){
    negVectSim = 1 - cor(v,n, method = "pearson")
    #print(paste("pearsDist",negVectSim))
  }
  
  # negCos = -1*(v %*% n)/(sqrt(sum(v^2))*sqrt(sum(n^2))) 
  # print(paste("negCos",negCos))
  # pearsDist = 1 - cor(v,n)
  # print(paste("pearsDist",pearsDist))
  # print(cor(v,n))
  
  dists = list()
  dists[["invDist"]] = invDist
  dists[["negVectSim"]] = negVectSim
  dists[["myDist"]] = invDist*negVectSim
  return(dists)
}
```

Testing `myDist` on toy data... 
```{r test new dist, include=TRUE, fig.width=3, fig.height=3 }

pts = matrix(c(2,2,2,4,2,3,2,4,6,2,0,3), ncol =2)

newDists = matrix(NA,nrow = 4, ncol = 1)
for (i in seq(1,4)){
  print(i)
  print(pts[2+i,])
  newDists[i] = myDist(pts[1,],pts[2,],pts[2+i,])
}


plot(pts, col = c("black","blue","red","red","red","red"),xlim = c(0,4.5),ylim = c(-0.5,6.5), pch = c(16,16,16))
text(pts-0.2,labels = c("cell_i","proj_i","nn_i","nn_i","nn_i","nn_i"))
text(pts+0.2, labels = c("","",newDists))
legend(3.5,6,legend = c("cell_i","proj_i","nn_i"), col = c("black","blue","red"),pch = c(16,16,16))


```

Finding k nearest projected neigbors by minimizing `myDist`...
```{r projected neighbor based on new dist}
# k nearest neighbors based on projected states and given custom distance metric 
projectedNeighbors = function(observed,projected,k,distance_metric="L2",similarity_metric="cosine",similarity_threshold = -1){
  #observed: genes x cells matrix of observed cells 
  #projected: genes x cells matrix of projected states of cells in observed (same order)
  #k: number of nearest neighbors 
  #distance_metric: "L1" or "L2" 
  #similarity_metric: "cosine" or "pearson". NOTE" pearson similarity behaves weird with two dimensions 
  #similarity_threshold: minimum similarity between velocity vector and cell_i-->nn_i vector for edge to be included. default all included. 
  
  observed = t(observed)
  projected = t(projected)
  n = nrow(observed)
  
  nn_idx = matrix(NA,nrow=nrow(observed), ncol = 1) #projected nearest neighbor 
  knn_idx = matrix(NA,nrow=nrow(observed), ncol = k) #projected k nearest neighbors 
  all_dists = matrix(NA,nrow = n, ncol = n)
  all_invDist = matrix(NA,nrow = n, ncol = n)
  all_negVectSim = matrix(NA,nrow = n, ncol = n)
  
  for (i in seq(1,nrow(observed))){
    cell_i = observed[i,] #current cell whose projected neighbor we want to find
    proj_i = projected[i,] #projected state of cell i 
    obs_exc_i = observed[-i,] #cell_i can't be its own projected neighbor - remove from consideration
    
    nn_dists_i = matrix(NA, nrow=nrow(obs_exc_i), ncol = 1) #distances of all other observed cells from cell_i
    nn_invDist_i = matrix(NA, nrow=nrow(obs_exc_i), ncol = 1) #inverse distance component
    nn_negVectSim_i = matrix(NA, nrow=nrow(obs_exc_i), ncol = 1) #negative similarity component
    
    #calculate distances between cell_i and all other cells j [USE SAPPLY HERE???]
    for (j in seq(1,nrow(obs_exc_i))){
      nn_j = obs_exc_i[j,] 
      dist_j = myDist(cell_i,proj_i,nn_j,distance_metric,similarity_metric) #distance between cell_i and current cell_j
      nn_dists_i[j] = dist_j$myDist
      nn_invDist_i[j] = dist_j$invDist
      nn_negVectSim_i[j] = dist_j$negVectSim
    }
    
    
    #add cell_i's dists to all_dists 
    all_dists[i,-i] = nn_dists_i
    all_invDist[i,-i] = nn_invDist_i
    all_negVectSim[i,-i] = nn_negVectSim_i
    
    #find index of minimum distance between cell_i and other cells --> nn_i 
    min_dist_idx = which(nn_dists_i==min(nn_dists_i))
    #find indices of k nearest neighbors 
    k_min_dists_idx = order(nn_dists_i)[1:k]
    #exclude neighbor if similarity below threshold 
    sim_nn_k = nn_negVectSim_i[k_min_dists_idx] #similarities of minimum distance neighbors 
    new_k_idx = k_min_dists_idx[sim_nn_k <= (-1*similarity_threshold)] #indices of minimum distane neighbors excluding those whose similarities are above threshold 
    
    #correct min_idx
    min_dist_idx[which(min_dist_idx>=i)] = min_dist_idx[which(min_dist_idx>=i)] + 1
    #correct min k idx 
    k_min_dists_idx[which(k_min_dists_idx>=i)] = k_min_dists_idx[which(k_min_dists_idx>=i)] + 1
    new_k_idx[which(new_k_idx>=i)] = new_k_idx[which(new_k_idx>=i)] + 1
    
    #add current cell's neighbors to all cell neighbors matrix
    nn_idx[i] = min_dist_idx
    #knn_idx[i,] = k_min_dists_idx
    if (length(new_k_idx)>0){
      knn_idx[i,c(1:length(new_k_idx))] = new_k_idx
    }
    
  }
  dist_comp = list()
  dist_comp[["invDist"]] = all_invDist
  dist_comp[["negVectSim"]] = all_negVectSim
  out = list()
  out[['NNs']] = nn_idx
  out[['kNNs']] = knn_idx
  out[['all_dists']] = all_dists
  out[["dist_comp"]] = dist_comp
  return(out)
}

```

Testing `projectedNeighbors` on toy data...
```{r test new projected neighbor function, include=TRUE, fig.width=3, fig.height=3 }
obs = t(matrix(c(2,2,2,3,4,0,2,6,3,2), ncol =2))
exp = t(matrix(c(3,2,3,3,2,1,4,5,1,4), ncol =2))
obs_lab = paste("cell",seq(1,5))
exp_lab = paste("proj",seq(1,5))

plot(t(obs),xlim = c(1,4.5),ylim = c(-0.5,6.5), pch = c(16,16,16), col = "red")
points(t(exp), xlim = c(0,4.5),ylim = c(-0.5,6.5), pch = c(16,16,16), col = "blue")
text(t(obs)-0.2,labels = obs_lab)
text(t(exp)-0.2,labels = exp_lab)

nns = projectedNeighbors(obs,exp,4,"L2","cosine",0.75)

#text(t(obs)+0.2, labels = paste("proj neighbor:",nns$NNs))
#text(t(obs)+c(0.2,-0.2), labels = paste("invL1:",round(min(nns$dist_comp$invDist,na.rm = TRUE),2)))

#edgeListTest = cbind(seq(1:5),nns$kNNs[,1]) #k=1 
k=4
edgeListTest = matrix(nrow = 0, ncol = 2)
for (n in seq(1:k)){
  #print(n)
  edgeListTest = rbind(edgeListTest, cbind(seq(1,5),nns$kNNs[,n]))
}
edgeListTest = na.omit(edgeListTest)
newGtest = graph_from_edgelist(edgeListTest,directed =TRUE)
plot(newGtest)
gTestFD = layout_with_fr(newGtest)
plot(gTestFD, main = "FDG")
text(gTestFD-0.1,labels = paste("cell",seq(1:5)))

```

#### Construct graph with new distance function and multiple projected neighbors 
G6: force directed graph with no edge weights on subsample 
```{r, include=TRUE, fig.width=3, fig.height=3 }
subCellsNewNNs = projectedNeighbors(curr.sub,proj.sub,1)
subAllDists = subCellsNewNNs$all_dists
subCellsNewEdgeList = cbind(seq(1,ncells.sub),subCellsNewNNs$NNs)
#subCellsNewNNs = projectedNeighbors(curr,proj)
#subCellsNewEdgeList = cbind(seq(1,ncells),subCellsNewNNs)

g6 = graph_from_edgelist(subCellsNewEdgeList,directed =TRUE)
V(g6)$color = cell.color.sub 
#V(g6)$color = cell.color
plot(g6)
g6FD = layout_with_fr(g6,dim=2)
colnames(g6FD) = c("C1","C2")
rownames(g6FD) = colnames(curr.sub)
#rownames(g6FD) = colnames(curr)
#plot(g6FD, col = cell.color, pch = 16)

show.velocity.on.embedding.cor(scale(g6FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1)
text(scale(g6FD)+0.1,labels = seq(1,dim(g6FD)[1]))

show.velocity.on.embedding.cor(scale(emb.test.sub), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1)
text(scale(emb.test.sub)[rownames(g6FD),]+0.1,labels = seq(1,dim(g6FD)[1]))

```

```{r look at distribution of distances and min distances, eval = FALSE }
hist(subAllDists,breaks = 50)
allDistsMins = sapply(seq(1:ncol(subAllDists)), function(x) min(subAllDists[x,], na.rm = TRUE))
hist(allDistsMins,breaks = 50)
hist(subAllDists[1,],breaks = 69)


```

#### Use PCA coords instead of gene expression to make graph 
```{r calculate score of projected cell states, include=TRUE, fig.width=6, fig.height=3 }
pca = pcaInfo$pca
sigma = diag(pca$d)
#plot(pca$d,ylab = "Variance Explained", xlab = "PC")
u = pca$u
v = pca$v
row.names(v) = pcaInfo$geneNames

common.genes = sapply(row.names(curr), function(x) x %in% pcaInfo$geneNames)
curr.pca = curr[common.genes,]
vSub = v[row.names(curr.pca),]

par(mfrow = c(1,2))

curr.scores = t(curr.pca) %*% vSub
plot(curr.scores[,1:2], col = cell.color, main = 'Observed')

proj.pca = proj[common.genes,]
proj.scores = t(proj.pca) %*% vSub
plot(proj.scores[,1:2], col = cell.color, main = 'Projected')


```

G7: graph from PCA coordinates 
```{r use PCA coordinates to make graph instead of coordinates in gene expression space, include=TRUE, fig.width=3, fig.height=3}
set.seed(1)
curr.scores.cellsub = t(curr.scores[emb.test.sub.names,]) #### change here to change number of PCs included 
proj.scores.cellsub = t(proj.scores[emb.test.sub.names,]) ####

k=20
pcaSubNNs = projectedNeighbors(curr.scores.cellsub,proj.scores.cellsub,k,"L2","cosine",0.5)
pcaNewEdgeList = matrix(nrow = 0, ncol = 2)
for (n in seq(1:k)){
  #print(n)
  pcaNewEdgeList = rbind(pcaNewEdgeList, cbind(seq(1,ncells.sub),pcaSubNNs$kNNs[,n]))
}
pcaNewEdgeList = na.omit(pcaNewEdgeList)
#pcaNewEdgeList = cbind(seq(1,ncells.sub),pcaSubNNs$NNs)

g7 = graph_from_edgelist(pcaNewEdgeList,directed =TRUE)
V(g7)$color = cell.color.sub 
#V(g6)$color = cell.color
par(mfrow = c(1,2))
plot(g7)
g7FD = layout_with_fr(g7,dim=2)
colnames(g7FD) = c("C1","C2")
rownames(g7FD) = colnames(curr.scores.cellsub)
#rownames(g6FD) = colnames(curr)
#plot(g6FD, col = cell.color, pch = 16)

plot(scale(g7FD),col = cell.color.sub, pch = 16, main = "FDG cell coordinates")

show.velocity.on.embedding.cor(scale(g7FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1, main = "FDG embedding")
text(scale(g7FD)+0.1,labels = seq(1,dim(g7FD)[1]))

show.velocity.on.embedding.cor(scale(emb.test.sub), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1, main = "PCA embedding")
text(scale(emb.test.sub)[rownames(g7FD),]+0.1,labels = seq(1,dim(g7FD)[1]))



```



G8: Graph with k>1 from gene expression coordinates
```{r k>1 gene expression coordinates, include=TRUE, fig.width=3, fig.height=3}
set.seed(1)

k = 20
gexpSubNNs = projectedNeighbors(curr.sub,proj.sub,k,"L2","cosine",0.25)
gexpNewEdgeList = matrix(nrow = 0, ncol = 2)
for (n in seq(1:k)){
  #print(n)
  gexpNewEdgeList = rbind(gexpNewEdgeList, cbind(seq(1,ncells.sub),gexpSubNNs$kNNs[,n]))
}

gexpNewEdgeList = na.omit(gexpNewEdgeList)

g8 = graph_from_edgelist(gexpNewEdgeList,directed =TRUE)
V(g8)$color = cell.color.sub 
par(mfrow = c(1,2))
plot(g8)
g8FD = layout_with_fr(g8,dim=2)
colnames(g8FD) = c("C1","C2")
rownames(g8FD) = colnames(curr.sub)

plot(scale(g8FD),col = cell.color.sub, pch = 16, main = "FDG cell coordinates")

show.velocity.on.embedding.cor(scale(g8FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color.sub,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1, main = "FDG embedding")
text(scale(g8FD)+0.1,labels = seq(1,dim(g8FD)[1]))

show.velocity.on.embedding.cor(scale(emb.test.sub), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color.sub,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1, main = "PCA embedding")
text(scale(emb.test.sub)[rownames(g8FD),]+0.1,labels = seq(1,dim(g8FD)[1]))


```

```{r, eval = FALSE }
hist(gexpSubNNs$dist_comp$negVectSim,breaks  = 100)
```


#### Distance distributions 
```{r look at distribution of distances with increasing PCs, eval = FALSE}

curr.pc.dists = pcaSubNNs$all_dists
hist(curr.pc.dists,breaks = 100, ylim = c(0,40))
allDistsMins = sapply(seq(1:ncol(curr.pc.dists)), function(x) min(curr.pc.dists[x,], na.rm = TRUE))
hist(allDistsMins,breaks = 50)
hist(curr.pc.dists[1,],breaks = 50)

curr.pc.invEuc = pcaSubNNs$dist_comp$invEuc
hist(curr.pc.invEuc, breaks = 50,ylim = c(0,50))

curr.pc.negCos = pcaSubNNs$dist_comp$negCos
hist(curr.pc.negCos, breaks = 100)
```

```{r, eval = FALSE}
plot(curr.scores.cellsub[1,],curr.scores.cellsub[2,])
text(curr.scores.cellsub[1,c(1,2,171)],curr.scores.cellsub[2,c(1,2,171)],labels = colnames(curr.scores.cellsub)[c(1,2,171)])
```

