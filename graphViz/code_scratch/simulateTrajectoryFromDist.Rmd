---
title: "Simulate Trajectories from Distributions"
author: "LylaAtta"
date: "10/8/2020"
output: html_document
---

#### Setup and get data from scVelo
```{r setup, include=FALSE}
#using velo_splatter evironment 
knitr::opts_chunk$set(echo = FALSE)
library(Rcpp)
#library(reticulate)
library(igraph)
library(matie)
library(RANN)
library(velocyto.R)
library(MUDAN)
library(RSpectra)
library(umap)
library(Rtsne)
library(destiny)
library(splatter)
library(scater)
#library(dyngen)
#library(dyntoy)
source("projectedNeighbors.R")
```


```{r, eval = FALSE}
nCells = 700
t = runif(nCells,0,1)

#one branch 
u1 = 0.2-t
u2 = t-0.2
u = matrix(0,nCells) + (t>0.2)*sapply(c(1:nCells),function(x) cbind(u1,u2)[x,sample(c(1,2),1)])
v = matrix(0,nrow = nCells)

#two branches 
#u3 = 0.6-t
u3 = 0.2
u = matrix(0,nCells) + (t>0.2 & t<0.4)*sapply(c(1:nCells),function(x) cbind(u1,u2)[x,sample(c(1,2),1)]) + (t>0.4)*sapply(c(1:nCells), function(x) cbind(u1,u2,u3)[x,sample(c(1,2,3),1)])

#three branches
# u4 = -0.2
# v4 = t-0.4
# u = matrix(0,nCells) + (t>0.2 & t<0.4)*sapply(c(1:nCells),function(x) cbind(u1,u2)[x,sample(c(1,2),1)]) + (t>0.4)*sapply(c(1:nCells), function(x) cbind(u1,u2,u3,u4)[x,sample(c(1,2,3,4),1)])
# v = matrix(0,nCells) + (t>0.4)*sapply(c(1:nCells), function(x) cbind(v,v4)[x,sample(c(1,2),1)])


```

```{r current and projected trajectories}
nCells = 700
tgap = 0.2
tc = runif(nCells,0,1)
tp = tc + 0.15
plot(tc,tp)

#one branch 
#current
u1c = 0.2-tc
u2c = tc-0.2
b1traj = sample(c(1,2),nCells, replace = TRUE)
uc = matrix(0,nCells) + (tc>0.2)*sapply(c(1:nCells),function(x) cbind(u1c,u2c)[x,b1traj[x]])
vc = matrix(0,nrow = nCells)
#projected
u1p = 0.2-tp
u2p = tp-0.2
up = matrix(0,nCells) + (tp>0.2)*sapply(c(1:nCells),function(x) cbind(u1p,u2p)[x,b1traj[x]])
vp = matrix(0,nrow = nCells)

plot(tc,uc,col = "black")
points(tp,up, col = "red", pch = 4)
text(tc[c(400,100,30,55,60,350,700)],uc[c(400,100,30,55,60,350,700)]+0.1, label = c(400,100,30,55,60,350,700), pch = 16, col = "blue")
text(tp[c(400,100,30,55,60,350,700)],up[c(400,100,30,55,60,350,700)]+0.1, label = c(400,100,30,55,60,350,700), pch = 16, col = "green")

#two branches 
#u3 = 0.6-t
#current 
u3c = 0.2
b2traj = sample(c(1,2,3),nCells,replace = TRUE)
uc = matrix(0,nCells) + (tc>0.2 & tc<0.4)*sapply(c(1:nCells),function(x) cbind(u1c,u2c)[x,b1traj[x]]) + (tc>0.4)*sapply(c(1:nCells), function(x) cbind(u1c,u2c,u3c)[x,b2traj[x]])
#projected 
u3p = 0.2
up = matrix(0,nCells) + (tp>0.2 & tp<0.4)*sapply(c(1:nCells),function(x) cbind(u1p,u2p)[x,b1traj[x]]) + (tp>0.4)*sapply(c(1:nCells), function(x) cbind(u1p,u2p,u3p)[x,b2traj[x]])

plot(tc,uc,col = "black")
points(tp,up, col = "red", pch = 4)
text(tc[c(400,100,30,55,60,350,700)],uc[c(400,100,30,55,60,350,700)]+0.1, label = c(400,100,30,55,60,350,700), pch = 16, col = "blue")
text(tp[c(400,100,30,55,60,350,700)],up[c(400,100,30,55,60,350,700)]+0.1, label = c(400,100,30,55,60,350,700), pch = 16, col = "green")


#three branches
#current
u4c = -0.2
v4c = tc-0.4
b3traj.u = sample(c(1,2,3,4),nCells,replace = TRUE)
b3traj.v = sample(c(1,2),nCells,replace = TRUE)
uc = matrix(0,nCells) + (tc>0.2 & tc<0.4)*sapply(c(1:nCells),function(x) cbind(u1c,u2c)[x,b1traj[x]]) + (tc>0.4)*sapply(c(1:nCells), function(x) cbind(u1c,u2c,u3c,u4c)[x,b3traj.u[x]])
vc = matrix(0,nCells) + (tc>0.4)*sapply(c(1:nCells), function(x) cbind(vc,v4c)[x,b3traj.v[x]])
#projected
u4p = -0.2
v4p = tp-0.4
up = matrix(0,nCells) + (tp>0.2 & tp<0.4)*sapply(c(1:nCells),function(x) cbind(u1p,u2p)[x,b1traj[x]]) + (tp>0.4)*sapply(c(1:nCells), function(x) cbind(u1p,u2p,u3p,u4p)[x,b3traj.u[x]])
vp = matrix(0,nCells) + (tp>0.4)*sapply(c(1:nCells), function(x) cbind(vp,v4p)[x,b3traj.v[x]])


plot(tc,uc,col = "black")
points(tp,up, col = "red", pch = 4)
text(tc[c(400,100,30,55,60,350,700)],uc[c(400,100,30,55,60,350,700)]+0.1, label = c(400,100,30,55,60,350,700), pch = 16, col = "blue")
text(tp[c(400,100,30,55,60,350,700)],up[c(400,100,30,55,60,350,700)]+0.1, label = c(400,100,30,55,60,350,700), pch = 16, col = "green")




```

```{r removing intermediate}
trajA = (uc==0)
trajB = (uc==(tc-0.2))
trajC = (uc==(0.2-tc))
#trajD = (uc==(0.6-tc))
trajD = (uc==0.2)
trajE = (uc==-0.2)
notIntCells = which(!((tc<0.35)&(trajB)))

par(mfrow = c(1,2))
plot(tc[notIntCells],uc[notIntCells])
points(tp[notIntCells],up[notIntCells], col = "red")
plot(tc[notIntCells],vc[notIntCells])
points(tp[notIntCells],vp[notIntCells], col = "red")

#current - no intermediates
tc = tc[notIntCells]
tp = tp[notIntCells]
uc = uc[notIntCells]
up = up[notIntCells]
vc = vc[notIntCells]
vp = vp[notIntCells]
nCells = length(tc)



```



```{r, fig.width=6, fig.height=3.5 eval = FALSE}
par(mfrow = c(1,2))
plot(t,u)
plot(t,v)
# 
# 
# ### doesn't work, need to define branches
# to = t[order(t)]
# uo = u[order(t)]
# tc = to[0:650]
# uc = uo[0:650]
# tp = to[50:700]
# up = uo[50:700]
# plot(tc,uc, pch = 1)
# points(tp,up, pch = 4, col = "red")
# points(tc[c(400,100,30,55,60,350,700)],uc[c(400,100,30,55,60,350,700)], pch = 16, col = "blue")
# points(tp[c(400,100,30,55,60,350,700)],up[c(400,100,30,55,60,350,700)], pch = 16, col = "green")
# text(tc[c(400,100,30,55,60,350,700)],uc[c(400,100,30,55,60,350,700)]+0.1, label = c(400,100,30,55,60,350,700), pch = 16, col = "blue")
# text(tp[c(400,100,30,55,60,350,700)],up[c(400,100,30,55,60,350,700)]+0.1, label = c(400,100,30,55,60,350,700), pch = 16, col = "green")
```

```{r, eval = FALSE}
cn = paste0("C",c(1:700))
trajA = (uo==0)
trajB = (uo==(t-0.2))
trajC = (uo==(0.2-t))
#trajD = (u==(0.6-t))
trajD = (uo==0.2)
trajE = (uo==-0.2)

#defining projected for each branch
allbranches = cbind(trajA,trajB,trajC,trajD,trajE)
rownames(allbranches) = cn

n = length(cn)
ptGap = 10
co = cn[1:650] #observed cells
cp = unlist(sapply(c(1:(n-25)), function(x) {ifelse(is.na(which(allbranches[(x+ptGap):n,which(allbranches[co[x],])])[1]),co[x+1],
                                                    names(which(allbranches[(x+ptGap):n,which(allbranches[co[x],])])[1]))}))


projected.cells = unlist(sapply(c(1:(length(t.ord)-25)),
                                function(x) {ifelse(is.na(which(branch[(x+ptGap):length(t.ord),which(branch[observed.cells[x],])])[1]),observed.cells[x+1],
                                                    names(which(branch[(x+ptGap):length(t.ord),which(branch[observed.cells[x],])])[1]))}))





#remove intermediate
notIntCells = which(!((t<0.4)&(trajB)))


cols = matrix(NA,nCells)
cols[trajA] = "black"
cols[trajB] = "red"
cols[trajC] = "blue"
cols[trajD] = "green"
cols[trajE] = "cyan"

par(mfrow = c(1,2))
plot(t[notIntCells],u[notIntCells])
plot(t[notIntCells],v[notIntCells])

```

```{r genes, eval = FALSE}
nCorGenes = 75
nRandGenes = 200

set.seed(1)
#4 sets of 75 correlated genes 
g1 = sapply(c(1:nCorGenes), function(x) (((200*u)/(u^2 + t^2 + 0.2)) + rnorm(nCells,150,4))*rnorm(nCells,1,0.2)*rnorm(nCells,1,0.2))
g2 = sapply(c(1:nCorGenes), function(x) (((200*t)/(u^2 + t^2 + 0.6)) + rnorm(nCells,150,4))*rnorm(nCells,1,0.2)*rnorm(nCells,1,0.2))
g3 = sapply(c(1:nCorGenes), function(x) (((100*(u^2 + t^2) - 20)/(u^2 + t^2 + 0.2)) + rnorm(nCells,150,4))*rnorm(nCells,1,0.2)*rnorm(nCells,1,0.2))
g4 = sapply(c(1:nCorGenes), function(x) (((100*sqrt(v)) + rnorm(nCells,150,4))*rnorm(nCells,1,0.2)*rnorm(nCells,1,0.2)))

#200 uncorrelated genes
gRand = sapply(c(1:nRandGenes), function(x) rnorm(nCells,200,50)*rnorm(nCells,1,0.2))
allExp = cbind(g1,g2,g3,g4,gRand)

nGenes = ncol(allExp)

#drop out 
pDropout = 1/(1+exp((allExp/100)-1)) #probability of dropout as a function of expression
keep = matrix(runif(nCells*nGenes),nrow = nCells, ncol = nGenes)>pDropout
expDropout = (matrix(runif(nCells*nGenes),nrow = nCells, ncol = nGenes)>pDropout)*allExp
rownames(expDropout) = paste0("C",c(1:nCells))
colnames(expDropout) = paste0("G",c(1:nGenes))
names(t) = rownames(expDropout)

```


```{r gene expression current and projected}
nCorGenes = 75
nRandGenes = 200

#CURRENT 
set.seed(1)
#4 sets of 75 correlated genes 
g1c = sapply(c(1:nCorGenes), function(x) (((200*uc)/(uc^2 + tc^2 + 0.2)) + rnorm(nCells,150,4))*rnorm(nCells,1,0.2)*rnorm(nCells,1,0.2))
g2c = sapply(c(1:nCorGenes), function(x) (((200*tc)/(uc^2 + tc^2 + 0.6)) + rnorm(nCells,150,4))*rnorm(nCells,1,0.2)*rnorm(nCells,1,0.2))
g3c = sapply(c(1:nCorGenes), function(x) (((100*(uc^2 + tc^2) - 20)/(uc^2 + tc^2 + 0.2)) + rnorm(nCells,150,4))*rnorm(nCells,1,0.2)*rnorm(nCells,1,0.2))
g4c = sapply(c(1:nCorGenes), function(x) (((100*sqrt(vc)) + rnorm(nCells,150,4))*rnorm(nCells,1,0.2)*rnorm(nCells,1,0.2)))

#200 uncorrelated genes
gRandc = sapply(c(1:nRandGenes), function(x) rnorm(nCells,200,50)*rnorm(nCells,1,0.2))
allExpC = cbind(g1c,g2c,g3c,g4c,gRandc)

#PROJECTED
set.seed(1)
#4 sets of 75 correlated genes 
g1p = sapply(c(1:nCorGenes), function(x) (((200*up)/(up^2 + tp^2 + 0.2)) + rnorm(nCells,150,4))*rnorm(nCells,1,0.2)*rnorm(nCells,1,0.2))
g2p = sapply(c(1:nCorGenes), function(x) (((200*tp)/(up^2 + tp^2 + 0.6)) + rnorm(nCells,150,4))*rnorm(nCells,1,0.2)*rnorm(nCells,1,0.2))
g3p = sapply(c(1:nCorGenes), function(x) (((100*(up^2 + tp^2) - 20)/(up^2 + tp^2 + 0.2)) + rnorm(nCells,150,4))*rnorm(nCells,1,0.2)*rnorm(nCells,1,0.2))
g4p = sapply(c(1:nCorGenes), function(x) (((100*sqrt(vp)) + rnorm(nCells,150,4))*rnorm(nCells,1,0.2)*rnorm(nCells,1,0.2)))

#200 uncorrelated genes
gRandp = sapply(c(1:nRandGenes), function(x) rnorm(nCells,200,50)*rnorm(nCells,1,0.2))
allExpP = cbind(g1p,g2p,g3p,g4p,gRandp)


nGenes = ncol(allExpC)

#drop out 
pDropout = 1/(1+exp((allExpC/100)-1)) #probability of dropout as a function of expression
keep = matrix(runif(nCells*nGenes),nrow = nCells, ncol = nGenes)>pDropout
expDropoutC = keep*allExpC
expDropoutP = keep*allExpP
rownames(expDropoutC) = rownames(expDropoutP) = paste0("C",c(1:nCells))
colnames(expDropoutC) = colnames(expDropoutP) = paste0("G",c(1:nGenes))
names(tc) = names(tp) = rownames(expDropoutC)




```


```{r}
par(mfrow = c(1,2))
heatmap(allExpC,Rowv = NA)
heatmap(allExpP,Rowv = NA)
```



```{r pca, fig.width=12, fig.height=3.5}
# expDropoutNoInt = expDropout[notIntCells,] #remove intermediate cells
# expDropout0 = expDropout
# expDropout = expDropoutNoInt
expDropout = expDropoutC
pca = svds(A = expDropout, k=50, opts = list(center = TRUE, scale = TRUE, maxitr = 2000, tol = 1e-10))
var = pca$d
plot(var) # ~3 components 
pcs = pca$u
rownames(pcs) = rownames(expDropout)
emb.pca = pcs[,1:2]
#plot(emb.pca,pch=4)

par(mfrow = c(1,4))

com = getComMembership(pcs[,1:5], k=150, method = igraph::cluster_louvain)
cluster.label = factor(com)
cell.cols = MUDAN:::fac2col(cluster.label)
cluster.cols = sapply(levels(cluster.label), function(x) cell.cols[which(cluster.label==x)[1]])
plot(scale(emb.pca), pch=16, xlab = 'PC1', ylab = 'PC2', col = cell.cols, main="PCA:\nsimulated trajectories")
#legend(x = -0.5, y= -0.5, legend = levels(cluster.label), col = cluster.cols, pch = 16)

set.seed(1)
umap = umap(pca$u[,1:5])$layout
plot(umap,pch=4,col = cell.cols,main="UMAP:\nsimulated trajectories")

set.seed(1)
tsne = Rtsne(pcs[,1:5], is_distance = FALSE, perplexity = 10, num_threads =1, verbose = FALSE)$Y
plot(tsne,pch=4,col=cell.cols,main="tSNE:\nsimulated trajectories")

set.seed(1)
diffmap = DiffusionMap(pcs[,1:5])
diffmap = eigenvectors(diffmap)[,1:2]
plot(diffmap,pch=4,col=cell.cols,main="Diffusion map:\nsimulated trajectories")

```

```{r, eval = FALSE}
t.ord = t[order(t)]
t.ord = t[order(t[notIntCells])] #removing intermediats

names(trajA) = rownames(expDropout0)
names(trajB) = rownames(expDropout0)
names(trajC) = rownames(expDropout0)
names(trajD) = rownames(expDropout0)
names(trajE) = rownames(expDropout0)

trajA = trajA[names(t.ord)]
trajB = trajB[names(t.ord)]
trajC = trajC[names(t.ord)]
trajD = trajD[names(t.ord)]
trajE = trajE[names(t.ord)]
branch = cbind(trajA,trajB,trajC,trajD,trajE)

observed.cells = names(t.ord)[1:(length(t.ord)-25)]
#for projected cells: for each cell
#find next cell in branch after pseudotime gap
#if no cells remain in branch: 
ptGap = 10
projected.cells = unlist(sapply(c(1:(length(t.ord)-25)),
                                function(x) {ifelse(is.na(which(branch[(x+ptGap):length(t.ord),which(branch[observed.cells[x],])])[1]),observed.cells[x+1],
                                                    names(which(branch[(x+ptGap):length(t.ord),which(branch[observed.cells[x],])])[1]))}))




observed = expDropout0[observed.cells,]
projected0 = expDropout0[projected.cells,] 
noise = 1
projected = projected0 + (projected0>0)*matrix(rnorm(nrow(projected0)*ncol(projected0),0,noise), nrow = nrow(projected0), ncol = ncol(projected0))
rownames(projected) = rownames(observed)
cell.cols.obs = cell.cols[rownames(observed)]

pca.obs = svds(A = observed, k=50, opts = list(center = TRUE, scale = TRUE, maxitr = 2000, tol = 1e-10))
var = pca$d
plot(var) # ~3 components 
pcs.obs = pca.obs$u
rownames(pcs.obs) = rownames(observed)
emb.pca = pcs.obs[,1:2]
plot(scale(emb.pca), pch=16, xlab = 'PC1', ylab = 'PC2', col = cell.cols.obs, main="PCA: simulated trajectories")

```


```{r}
v.curr = pca$v 

curr.scores = expDropoutC %*% v.curr
proj.scores = expDropoutP %*% v.curr

par(mfrow = c(1,2))
curr.scores.scale = scale(curr.scores[,1:2])
proj.scores.scale = scale(proj.scores[,1:2])
plot(curr.scores.scale,pch=16, xlab = 'PC1', ylab = 'PC2', col = cell.cols, main="PCA: simulated observed cells") #xlim = c(-2,2),ylim = c(-2,3)
text(curr.scores.scale[c(4,10,30,55,60,350,570),1],curr.scores.scale[c(4,10,30,55,60,350,570),2],label = c(4,10,30,55,60,350,570), pch = 4)
plot(proj.scores.scale,pch=16, xlab = 'PC1', ylab = 'PC2', col = cell.cols, main="PCA: simulated projected cells")
text(proj.scores.scale[c(4,10,30,55,60,350,570),1],proj.scores.scale[c(4,10,30,55,60,350,570),2],label = c(4,10,30,55,60,350,570),pch = 4)
```

```{r, fig.width=6, fig.height=7}
source('projectedNeighbors.R')
#par(mfrow = c(1,2))
set.seed(1)
g = graphViz(observed = t(curr.scores[,c(1:4)]), projected = t(proj.scores[,c(1:4)]),
         k = 5, distance_metric = "L2", similarity_metric = "cosine", similarity_threshold = 0.5, weighted = TRUE, 
         cell.colors = cell.cols, title = "veloviz embedding", 
         plot = TRUE, return_graph = TRUE)
```
```{r}
source('projectedNeighbors.R')
#par(mfrow = c(1,2))
set.seed(1)
g = graphViz(observed = t(curr.scores[,c(1:4)]), projected = t(proj.scores[,c(1:4)]),
         k = 5, distance_metric = "L2", similarity_metric = "cosine", similarity_threshold = 0.25, weighted = TRUE, 
         cell.colors = cell.cols.obs, title = "veloviz embedding", 
         plot = TRUE, return_graph = TRUE)


```

