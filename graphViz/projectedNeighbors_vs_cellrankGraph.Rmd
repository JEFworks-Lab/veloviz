---
title: "Comparing projectedNeighbors to graph from cell rank"
author: "LylaAtta"
date: "10/26/2020"
output: html_document
---

cellRank builds a graph based on a transition matrix. The transition matrix contains the probabilities of cell-->cell transitions, which are calculated as a weighted average between (similarity of velocity vector and cell difference vector) and (euclidean similarity in PCA space). Here, we want to compare this graph to the graph that we build using projectedNeighbors. 

#### Setup and get data from scVelo
```{r setup, include=FALSE}
#using velocyto2 evironment 
knitr::opts_chunk$set(echo = FALSE)
library(reticulate)
library(igraph)
library(matie)
library(RANN)
library(velocyto.R)
library(MUDAN)
library(RSpectra)
library(umap)
library(Rcpp)
source("projectedNeighbors_weightedCD.R")
```

Use the reticulate package to use scVelo/cellrank from within R:   
```{r importing scvelo}
use_condaenv("cellrank",required = TRUE)
scv = import("scvelo")
sc = import("scanpy")
cr = import("cellrank")
np = import("numpy")
#scv$logging$print_version()
```


load pancreas data  
```{r loading panc data, message=FALSE}
adata = cr$datasets$pancreas()
#scv$pl$scatter(adata,legend_loc = "lower left", size = 60)
scv$utils$show_proportions(adata)

emb_pca = adata$obsm['X_pca'] #extract pca embedding 
emb_umap = adata$obsm['X_umap'] #extract umap embedding 
clusters = adata$obs$clusters #extract clusters 
rownames(emb_umap) = names(clusters) = adata$obs_names$values

col = rainbow(length(levels(clusters)),s = 0.8, v = 0.8) 
cell.cols = col[clusters] #color according to cluster
names(cell.cols) = names(clusters)
```

```{r plot panc data on umap, included = FALSE}
plot(emb_pca, col = cell.cols, pch=16, xlab = "PC1", ylab = "PC2")
plot(emb_umap, col = cell.cols, pch=16, xlab = "UMAP X", ylab = "UMAP Y", xlim = c(-15,20))
legend(x=10, y=6, legend = levels(clusters), col = col, pch = 16)
```



#### Run scVelo 
```{r filter normalize log transform}
scv$pp$filter_and_normalize(adata, min_shared_counts = as.integer(20), n_top_genes = as.integer(2000))
sc$tl$pca(adata)
sc$pp$neighbors(adata, n_pcs = as.integer(30), n_neighbors = as.integer(30))
scv$pp$moments(adata, n_pcs = 30, n_neighbors = 30)

adata
```

```{r}
emb_pca = adata$obsm['X_pca'] #extract pca embedding 
plot(emb_pca, col = cell.cols, pch=16, xlab = "UMAP X", ylab = "UMAP Y", xlim = c(-15,20))
legend(x=10, y=6, legend = levels(clusters), col = col, pch = 16)

```

Run velocity  
```{r}
scv$tl$velocity(adata, mode = "dynamical")
scv$tl$velocity_graph(adata)
scv$pl$velocity_embedding_stream(adata, basis = "umap", legend_fontsize = 12, title = '', smooth = 0.8, min_mass=4)
```

Run cellrank  
```{r}
cr$tl$terminal_states(adata,cluster_key = 'clusters', weight_connectivities = 0.2)
cr$pl$terminal_states(adata)
cr$tl$initial_states(adata, cluster_key = 'clusters')
cr$pl$initial_states(adata, discrete = TRUE)
```

Extract transition matrices  
```{r}
ck = cr$tl$kernels$ConnectivityKernel(adata) #connectivity kernel
vk = cr$tl$kernels$VelocityKernel(adata) #velocity kernel

ck$compute_transition_matrix() #compute connectivity transition matrix
vk$compute_transition_matrix() #velocity transition matrix

ctm = ck$transition_matrix #transition matrix - connectivities
vtm = vk$transition_matrix #transition matrix - velocities

tm_combined = (0.8*vtm) + (0.2*ctm) #weighted average of velocity and connectivity transition matrices

sum(ctm>0)
sum(vtm>0)
sum(tm_combined>0)
par(mfrow = c(1,3))
hist(as.numeric(ctm[which(ctm>0)]), breaks = 500, main = "Connectivities Transition Probabilities")
hist(as.numeric(vtm[which(vtm>0)]), breaks = 500, main = "Velocities Transition Probabilities")
hist(as.numeric(tm_combined[which(tm_combined>0)]), breaks = 500, main = "Averaged Transition Probabilities")

```

```{r, fig.width=10, fig.height=5}
par(mfrow = c(1,3))
cg = graph_from_adjacency_matrix(ctm, mode = "directed", weighted = TRUE)
set.seed(1)
cfdg = layout_with_fr(cg, dim = 2)
plot(cfdg, pch = 16, col = cell.cols, main = "distances")

vg = graph_from_adjacency_matrix(vtm, mode = "directed", weighted = TRUE)
set.seed(1)
vfdg = layout_with_fr(vg, dim = 2)
plot(vfdg, pch = 16, col = cell.cols, main = "velocities")

g = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
set.seed(100)
fdg = layout_with_fr(g, dim = 2)
plot(fdg, pch = 16, col = cell.cols, main = "combined")

g = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
set.seed(1)
fdg = layout_with_fr(g, dim = 2)
plot(fdg, pch = 16, col = cell.cols, main = "combined, seed = 1")

g = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
set.seed(30)
fdg = layout_with_fr(g, dim = 2)
plot(fdg, pch = 16, col = cell.cols, main = "combined, seed = 30")

g = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
set.seed(100)
fdg = layout_with_fr(g, dim = 2)
plot(fdg, pch = 16, col = cell.cols, main = "combined, seed = 100")



```


```{r different weights, fig.height=10, fig.width = 8}
ws = c(0,0.25,0.5,0.75,0.8,1)

par(mfrow = c(3,2))
for (w in ws){
  
  tm_combined = (w*vtm) + ((1-w)*ctm) #weighted average of velocity and connectivity transition matrices
  g = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
  set.seed(1)
  fdg = layout_with_fr(g, dim = 2)
  plot(fdg, pch = 16, col = cell.cols, main = paste("weight = ",w))
  
}



```


### Use composite distance 

Extract count data..  
```{r extract counts, message = FALSE, results='hide', included = FALSE}
spliced = as.matrix(t(adata$layers['spliced']))
unspliced = as.matrix(t(adata$layers['unspliced']))
cells = adata$obs_names$values
genes = adata$var_names$values
colnames(spliced) = colnames(unspliced) = cells
rownames(spliced) = rownames(unspliced) = genes
```

```{r}
mns = rowMeans(spliced)
sds = sapply(c(1:nrow(spliced)), function(x) sd(spliced[x,]))
mnu = rowMeans(unspliced)
sdu = sapply(c(1:nrow(unspliced)), function(x) sd(unspliced[x,]))

par(mfrow = c(2,2))
hist(log10(mns+1), breaks = 500, main = "log10(mean gene expression) spliced")
hist(log10(mnu+1), breaks = 500, main = "log10(mean gene expression) unspliced")
plot(log10(mns+1),log10(sds+1), main = "log10(Std Dev) vs \nlog10(mean gene expression) spliced")
plot(log10(mnu+1),log10(sds+1), main = "log10(Std Dev) vs \nlog10(mean gene expression) unspliced")


```



Filter genes  
```{r filter genes, message = FALSE , included = FALSE}
gexpS = log10(rowSums(spliced)+1)
gexpU = log10(rowSums(unspliced)+1)
plot(gexpS,gexpU)
# use same genes 
# goodGenes = genes[gexpS > 1 & gexpU > 1]
# spliced = spliced[goodGenes,]
# unspliced = unspliced[goodGenes,]
```

Downsample cells to make things easier  
```{r downsample, results='hide', included = FALSE}
spliced.sub = spliced[,seq(1,ncol(spliced),by=1)]
cell.names.pca = colnames(spliced.sub)
unspliced.sub = unspliced[,seq(1,ncol(unspliced),by=1)]
#cell.dist.sub = as.dist(1-cor(t(pcs[seq(1,ncol(unspliced),by=3),])))
cell.cols.sub = cell.cols[colnames(spliced.sub)]
```

Normalize for dimensional reduction  
```{r normalize, results='hide', included = FALSE}
allExp = spliced.sub + unspliced.sub #use combined spliced and unspliced counts 
#all.cpm = MUDAN::normalizeCounts(allExp) #cpm normalize
all.norm = MUDAN::normalizeVariance(allExp,details = TRUE, plot = FALSE) #variance stabilize 
odsGenes = goodGenes[all.norm$ods] #overdispersed genes
all.logODS = as.matrix(t(all.norm$mat[all.norm$ods,])) #keep overdispersed genes 
```
```{r fig.width=10}
#look at distribution of gene expression
mna = rowMeans(allExp)
sda = sapply(c(1:nrow(allExp)), function(x) sd(allExp[x,]))
#mnc = rowMeans(all.cpm)
#sdc = sapply(c(1:nrow(all.cpm)), function(x) sd(all.cpm[x,]))
mnv = rowMeans(all.norm$mat)
sdv = sapply(c(1:nrow(all.norm$mat)), function(x) sd(all.norm$mat[x,]))
mno = colMeans(all.logODS)
sdo = sapply(c(1:ncol(all.logODS)), function(x) sd(all.logODS[,x]))

par(mfrow = c(2,3))
hist(log10(mna+1), breaks = 500, main = "log10(mean gene exp)")
#hist(log10(mnc+1), breaks = 500, main = "log10(mean gene normalized)")
hist(mnv, breaks = 500, main = "mean gene exp variance stabilized")
hist(mno, breaks = 500, main = "mean gene exp overdispersed")
plot(log10(mna+1),log10(sda+1), main = "log10(Std Dev) vs \nlog10(mean gene exp)")
#plot(log10(mnc+1),log10(sdc+1), main = "log10(Std Dev) vs \nlog10(mean gene normalized)")
plot(mnv,sdv, main = "Std Dev vs \nmean gene exp variance stabilized")
plot(mno,sdo, main = "Std Dev vs mean \ngene exp overdispersed")

#all.logODS ~normal, no mean-variance dependence --> pca 
```



Dimensional reduction  
```{r dimensional reduction, included = FALSE}
pca = svds(A = all.logODS, k=50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var = pca$d
plot(var) # ~10 components 

emb.pca = pca$u[,1:2]
row.names(emb.pca) = row.names(all.logODS)
plot(emb.pca, col = cell.cols.sub, pch = 16, xlab = "PC1", ylab = "PC2", main = "PCA on subsampled data")


#pairwise cell dists for velocity calculation 
cell.dist = as.dist(1-cor(t(pca$u)))
```


Run velocyto on panc data  
```{r velocity, message = FALSE, results = 'hide', included = FALSE}
#vel = gene.relative.velocity.estimates(spliced.sub,unspliced.sub,deltaT=1,kCells=30,cell.dist=cell.dist,fit.quantile=0.1,mult=100)
saveRDS(vel,file = "panc_vel_cellrank.rds")
vel = readRDS("./saved_objects/panc_vel_cellrank.rds")
curr = vel$current
proj = vel$projected

#show velocity on PCA
# show.velocity.on.embedding.cor(scale(emb.pca), vel, n=100, scale='sqrt', cell.colors=cell.cols.sub,cex=1, arrow.scale=1, show.grid.flow=TRUE,min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2, main = "Velocities on PCA embedding")

# #show velocity on UMAP 
# emb.umap.sub = emb_umap[rownames(emb.pca),]
# show.velocity.on.embedding.cor(scale(emb.umap.sub), vel, n=100, scale='sqrt', cell.colors=cell.cols.sub,cex=1, arrow.scale=1, show.grid.flow=TRUE,min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2, main = "Velocities on UMAP embedding")

```  

```{r}
#look at gene exp distribution in curr and proj

par(mfrow = c(2,2))
currmeans = log10(rowMeans(curr)+1)
currsds = log10(sapply(c(1:nrow(curr)), function(x) sd(curr[x,]))+1)
hist(currmeans,breaks = 500, main = "curr: log mean gene exp")
plot(currmeans,currsds, main = "curr: log means vs log sds")

projmeans = log10(rowMeans(proj)+1)
projsds = log10(sapply(c(1:nrow(proj)), function(x) sd(proj[x,]))+1)
hist(projmeans,breaks = 500, main = "proj: log mean gene exp")
plot(projmeans,projsds, main = "proj: log means vs log sds")

curr.norm = MUDAN::normalizeVariance(curr,details = FALSE, plot = FALSE) #variance stabilize 
proj.norm = MUDAN::normalizeVariance(proj,details = FALSE, plot = FALSE) #variance stabilize 

par(mfrow = c(2,2))
curr.norm.means = log10(rowMeans(curr.norm)+1)
curr.norm.sds = log10(sapply(c(1:nrow(curr.norm)), function(x) sd(curr.norm[x,]))+1)
hist(curr.norm.means, breaks = 500)
plot(curr.norm.means, curr.norm.sds)

proj.norm.means = log10(rowMeans(proj.norm)+1)
proj.norm.sds = log10(sapply(c(1:nrow(proj.norm)), function(x) sd(proj.norm[x,]))+1)
hist(proj.norm.means, breaks = 500)
plot(proj.norm.means, proj.norm.sds)

#curr.norm and proj.norm ~normal and no mean-variance dependence --> pca 

```

```{r}
pca.velo = svds(A = t(curr.norm), k=50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var = pca.velo$d
plot(var) # ~10 components 

emb.pca.velo = pca.velo$u[,1:2]
row.names(emb.pca.velo) = colnames(curr.norm)
plot(emb.pca.velo, col = cell.cols.sub, pch = 16, xlab = "PC1", ylab = "PC2", main = "PCA on subsampled data")


```


Scores of observed and projected states in PC space  
```{r pc scores, included = FALSE}
u = pca.velo$u #scores
v = pca.velo$v #loads
row.names(v) = rownames(curr.norm)

common.genes = sapply(row.names(curr.norm), function(x) x %in% odsGenes)
common.genes.names = rownames(curr.norm)[common.genes]
curr.pca = curr.norm[common.genes,]
v.sub = v[row.names(curr.pca),]

par(mfrow = c(1,2))
curr.scores = scale(t(curr.pca)) %*% v.sub
plot(curr.scores[,1:2], col = cell.cols.sub, main = 'Observed')#,xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))

proj.pca = proj.norm[common.genes,]
proj.scores = scale(t(proj.pca)) %*% v.sub
plot(proj.scores[,1:2], col = cell.cols.sub, main = 'Projected')#,xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))

```

Graph visualization on subset of cells from PC coordinates  
```{r graph viz from PCs, results = "hide", fig.height=10, fig.width = 8}
source("projectedNeighbors_weightedCD.R")
ws = c(0.1,1,10,25,50,100)
par(mfrow = c(3,2))
for (w in ws){
  set.seed(1)
  vizg = graphViz(t(curr.scores), t(proj.scores), k=30, distance_metric = "L2", similarity_metric = "cosine", distance_weight = w, similarity_threshold = 0, weighted = TRUE, cell.colors = cell.cols.sub,plot = TRUE, return_graph = TRUE,title = paste("Weight = ", w))
}






```

#### Calculate velocity on subsampled data 
1232 cells  

```{r, include = FALSE, eval = FALSE}
#create anndata object with subsampled data
# gene.names.sub = rownames(spliced.sub)
# clusters.pca = clusters[cell.names.pca]
# dfobs = data.frame(as.character(clusters.sub),row.names = as.character(cell.names.pca))
# colnames(dfobs) = "clusters"
# dfvar = data.frame(as.character(gene.names.sub),row.names = as.character(gene.names.sub))
# colnames(dfvar) = "Genes"
# ad = import("anndata",convert = FALSE)
# 
# adata.sub = ad$AnnData(
#   X = t(allExp),
#   obs = dfobs,
#   layers = list('spliced' = t(spliced.sub),'unspliced' = t(unspliced.sub))
# )

# scv$pp$filter_genes(adata.sub)
# scv$pp$moments(adata.sub)
# scv$tl$recover_dynamics(adata.sub)

# adata.sub$write('./data/pancreas_sub.h5ad')
adata.sub = scv$read('./data/pancreas_sub.h5ad')

scv$tl$velocity(adata.sub, mode = 'dynamical')
scv$tl$velocity_graph(adata.sub)

vGraph.sub = py_to_r(adata.sub$uns['velocity_graph'])
colnames(vGraph.sub) = cell.names.pca
rownames(vGraph.sub) = cell.names.pca

```

```{r, include = FALSE, eval = FALSE}
# scv$tl$umap(adata.sub)
# scv$pl$velocity_embedding_stream(adata.sub,basis ='umap')

```

Run scvelo velocity on same subset used to make fdg graph  
```{r}
#create anndata object with subsampled data
# ad = import("anndata",convert = FALSE)
# 
# allExp.sub = allExp[,cell.names.sub]
# spliced.sub.sub = spliced[,cell.names.sub]
# unspliced.sub.sub = unspliced[,cell.names.sub]
# 
# gene.names.sub = rownames(spliced.sub)
# clusters.sub = clusters[cell.names.sub]
# dfobs = data.frame(as.character(clusters.sub),row.names = as.character(cell.names.sub))
# colnames(dfobs) = "clusters"
# dfvar = data.frame(as.character(gene.names.sub),row.names = as.character(gene.names.sub))
# colnames(dfvar) = "Genes"
# 
# adata.sub.sub = ad$AnnData(
#   X = t(allExp.sub),
#   obs = dfobs,
#   layers = list('spliced' = t(spliced.sub.sub),'unspliced' = t(unspliced.sub.sub))
# )
# 
# scv$pp$filter_genes(adata.sub.sub)
# scv$pp$moments(adata.sub.sub)
# scv$tl$recover_dynamics(adata.sub.sub)
# 
# adata.sub.sub$write('./data/pancreas_sub_sub.h5ad')
adata.sub.sub = scv$read('./data/pancreas_sub_sub.h5ad')

scv$tl$velocity(adata.sub.sub, mode = 'dynamical')
scv$tl$velocity_graph(adata.sub.sub)

vGraph.sub.sub = as.matrix(adata.sub.sub$uns['velocity_graph'])
colnames(vGraph.sub.sub) = cell.names.sub
rownames(vGraph.sub.sub) = cell.names.sub

```

```{r, include = FALSE, eval = FALSE}
# scv$tl$umap(adata.sub.sub)
# scv$pl$velocity_embedding_stream(adata.sub.sub,basis ='umap')
```

Make graph  
```{r, fig.width=8, fig.height=8}
vGraphUnweighted = vGraph.sub.sub>0
vGraphUnweighted = vGraphUnweighted*1

g = graph_from_adjacency_matrix(vGraphUnweighted,mode = "directed")
#plot(g)
par(mfrow = c(2,2))
set.seed(5)
fdg1 = layout_with_fr(g, dim = 2)
colnames(fdg1) = c("C1","C2")
rownames(fdg1) = cell.names.sub
plot(scale(fdg1), col = cell.cols.grph, pch = 16, main = "scvelo velocity graph - unweighted", xlab = "", ylab = "")
set.seed(30)
fdg = layout_with_fr(g, dim = 2)
colnames(fdg) = c("C1","C2")
rownames(fdg) = cell.names.sub
plot(scale(fdg), col = cell.cols.grph, pch = 16, main = "scvelo velocity graph - unweighted", xlab = "", ylab = "")

g_wts = graph_from_adjacency_matrix(vGraph.sub.sub,mode = "directed",weighted = TRUE)
#plot(g_wts)
set.seed(1)
fdg_wts1 = layout_with_fr(g_wts, dim = 2)
colnames(fdg_wts1) = c("C1","C2")
rownames(fdg_wts1) = cell.names.sub
plot(scale(fdg_wts1), col = cell.cols.grph, pch = 16, main = "scvelo velocity graph - weighted", xlab = "", ylab = "")
set.seed(5)
fdg_wts = layout_with_fr(g_wts, dim = 2)
colnames(fdg_wts) = c("C1","C2")
rownames(fdg_wts) = cell.names.sub
plot(scale(fdg_wts), col = cell.cols.grph, pch = 16, main = "scvelo velocity graph - weighted", xlab = "", ylab = "")
```

```{r velocity projections, results = "hide"}
show.velocity.on.embedding.cor(scale(fdg1), vel, n=100, scale='sqrt', cell.colors=cell.cols.sub,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1, main = "scvelo graph unweighted")
show.velocity.on.embedding.cor(scale(fdg_wts1), vel, n=100, scale='sqrt', cell.colors=cell.cols.sub,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1, main = "scvelo graph weighted")
```


#### Compare consistency scores
```{r consistency scores, results = "hide", fig.width = 8, fig.height=8}
deltaExp = vel$deltaE[,cell.names.sub]

#our graph 1
set.seed(1)
g0 = graphViz(curr.scores.cellsub,proj.scores.cellsub,10,"L2","cosine",0.25,cell.cols.grph,title = "K = 10", plot = FALSE, return_graph = TRUE)
g0_coords = g0$fdg_coords
g0_scores = consistency(g0_coords,deltaExp,20,FALSE)

#our graph 2
set.seed(20)
g1 = graphViz(curr.scores.cellsub,proj.scores.cellsub,10,"L2","cosine",0.25,cell.cols.grph,title = "K = 10", plot = FALSE, return_graph = TRUE)
g1_coords = g0$fdg_coords
g1_scores = consistency(g0_coords,deltaExp,20,FALSE)

#scvelo graph unweighted 1
set.seed(5)
g2_coords = layout_with_fr(g, dim = 2)
g2_scores = consistency(g2_coords,deltaExp,20,FALSE)

#scvelo graph unweighted 2
set.seed(30)
g3_coords = layout_with_fr(g, dim = 2)
g3_scores = consistency(g3_coords,deltaExp,20,FALSE)

#scvelo graph weighted 1
set.seed(1)
g4_coords = layout_with_fr(g_wts, dim = 2)
g4_scores = consistency(g4_coords,deltaExp,20,FALSE)

#scvelo graph weighted 2
set.seed(5)
g5_coords = layout_with_fr(g_wts, dim = 2)
g5_scores = consistency(g5_coords,deltaExp,20,FALSE)



par(mfrow = c(3,2))
x = c(-0.2,1)
y = c(0,12)
xt = "Cell Consistency Score"
hist(g0_scores,col="red",breaks = 100,xlab = xt, xlim = x, ylim = y, main="Our embedding 1")
text(x = c(0.05,0.05),y = c(11,10),labels = c(paste("Mean:",mean(g0_scores)),paste("Median:",median(g0_scores))))
hist(g1_scores,col="red",breaks = 100,xlab = xt, xlim = x, ylim = y,main="Our embedding 2")
text(x = c(0.05,0.05),y = c(11,10),labels = c(paste("Mean:",mean(g1_scores)),paste("Median:",median(g1_scores))))

hist(g2_scores,col="red",breaks = 100,xlab = xt, xlim = x, ylim = y, main="scVelo graph - unweighted 1")
text(x = c(0.05,0.05),y = c(11,10),labels = c(paste("Mean:",mean(g2_scores)),paste("Median:",median(g2_scores))))
hist(g3_scores,col="red",breaks = 100,xlab = xt, xlim = x, ylim = y, main="scVelo graph - unweighted 2")
text(x = c(0.05,0.05),y = c(11,10),labels = c(paste("Mean:",mean(g3_scores)),paste("Median:",median(g3_scores))))

hist(g4_scores,col="red",breaks = 100,xlab = xt, xlim = x, ylim = y, main="scVelo graph - weighted 1")
text(x = c(0.05,0.05),y = c(11,10),labels = c(paste("Mean:",mean(g4_scores)),paste("Median:",median(g4_scores))))
hist(g5_scores,col="red",breaks = 100,xlab = xt, xlim = x, ylim = y,main= "scVelo graph - weighted 2")
text(x = c(0.05,0.05),y = c(11,10),labels = c(paste("Mean:",mean(g5_scores)),paste("Median:",median(g5_scores))))

```

#### Threshold similarities 
first, look at distribution of all similarities to help pick threshold..  
```{r similarity distributions, fig.width = 6, fig.height=3}
#look at distribution of similarities 
all.sims = vGraph.sub.sub[which(vGraph.sub.sub>0)]
hist(all.sims, breaks = 300,xlab = 'Similarities from scvelo velocity graph') #looks like there's a natural cutoff at 0.3

```  

..looks like there are at least a couple of "populations" here..  

Let's try a few thresholds up to 0.3..  
```{r try multiple thresholds, fig.width=6, fig.height=8}
#make graphs with different thresholds 
ts = c(0,0.1,0.2,0.3)
par(mfrow = c(4,2))
for (t in ts){
  vGraph.thresh = (vGraph.sub.sub>t)*vGraph.sub.sub
  vGraph.thresh.unwt = (vGraph.sub.sub>t)*1
  
  #unweighted 
  g_thresh = graph_from_adjacency_matrix(vGraph.thresh.unwt,mode = "directed")
  #plot(g_thresh)
  set.seed(5)
  fdg_thresh = layout_with_fr(g_thresh, dim = 2)
  colnames(fdg_thresh) = c("C1","C2")
  rownames(fdg_thresh) = cell.names.sub
  plot(scale(fdg_thresh), col = cell.cols.grph, pch = 16, main = paste("scvelo velocity graph: unweighted,\n similarity threshold =",as.character(t)), xlab = "", ylab = "")
  
  #weighted 
  g_thresh_wt = graph_from_adjacency_matrix(vGraph.thresh,mode = "directed",weighted =  TRUE)
  #plot(g_thresh_wt)
  set.seed(5)
  fdg_thresh_wt = layout_with_fr(g_thresh_wt, dim = 2)
  colnames(fdg_thresh_wt) = c("C1","C2")
  rownames(fdg_thresh_wt) = cell.names.sub
  plot(scale(fdg_thresh_wt), col = cell.cols.grph, pch = 16, main = paste("scvelo velocity graph: weighted,\n similarity threshold =",as.character(t)), xlab = "", ylab = "")
}

```  

As we increase the threshold, the number of unconnected cells increases as expected. But this seems to be primarily affecting ductal cells (red/orange cluster).  
..looks like similarities between ductal cells are generally lower than in other cell types -- are they cycling? We might not have enough cells to capture cycling behavior..  
In weighted graph, ductal cells appear more spread out than other cell types. This makes sense given their lower similarities.  
