---
title: "Comparing projectedNeighbors to graph from cell rank"
author: "LylaAtta"
date: "10/26/2020"
output:
  html_document: default
  pdf_document: default
---

cellRank builds a graph based on a transition matrix. The transition matrix contains the probabilities of cell-->cell transitions, which are calculated as a weighted average between (similarity of velocity vector and cell difference vector) and (euclidean similarity in PCA space). Here, we want to compare this graph to the graph that we build using projectedNeighbors. 

#### Setup and get data from scVelo
```{r setup, include=FALSE}
#using velocyto2 evironment 
knitr::opts_chunk$set(echo = FALSE)
library(reticulate)
library(igraph)
library(matie)
library(RANN)
library(velocyto.R)
library(MUDAN)
library(RSpectra)
library(umap)
library(Rcpp)
source("projectedNeighbors_weightedCD.R")
```

Use the reticulate package to use scVelo/cellrank from within R:   
```{r importing scvelo}
use_condaenv("cellrank",required = TRUE)
scv = import("scvelo")
sc = import("scanpy")
cr = import("cellrank")
np = import("numpy")
pk = import("pickle")
#scv$logging$print_version()
```

## scVelo - whole trajectory 
Build graph with all data i.e. with cells from all parts of the trajectory.  

load complete adata from previous run  
```{r load previous}
adata = py_load_object("./saved_objects/cellrank_panc_adata.rds")
clusters = adata$obs$clusters #extract clusters 
cell.names = as.vector(adata$obs_names$values)
col = rainbow(length(levels(clusters)),s = 0.8, v = 0.8) 
cell.cols = col[clusters] #color according to cluster
names(cell.cols) = names(clusters) = cell.names
```

load pancreas data  
```{r loading panc data, message=FALSE, eval = FALSE}
adata = cr$datasets$pancreas()
#scv$pl$scatter(adata,legend_loc = "lower left", size = 60)
scv$utils$show_proportions(adata)

emb_pca = adata$obsm['X_pca'] #extract pca embedding
emb_umap = adata$obsm['X_umap'] #extract umap embedding
clusters = adata$obs$clusters #extract clusters
rownames(emb_umap) = names(clusters) = adata$obs_names$values

col = rainbow(length(levels(clusters)),s = 0.8, v = 0.8)
cell.cols = col[clusters] #color according to cluster
names(cell.cols) = names(clusters)
```

```{r plot panc data on umap, included = FALSE, eval = FALSE}
plot(emb_pca, col = cell.cols, pch=16, xlab = "PC1", ylab = "PC2")
plot(emb_umap, col = cell.cols, pch=16, xlab = "UMAP X", ylab = "UMAP Y", xlim = c(-15,20))
legend(x=13, y=0, legend = levels(clusters), col = cell.cols, pch = 16, cex = 0.7)
```

Run scVelo 
```{r filter normalize log transform, eval = FALSE}
scv$pp$filter_and_normalize(adata, min_shared_counts = as.integer(20), n_top_genes = as.integer(2000))
sc$tl$pca(adata)
sc$pp$neighbors(adata, n_pcs = as.integer(30), n_neighbors = as.integer(30))
scv$pp$moments(adata, n_pcs = 30, n_neighbors = 30)

adata
```

```{r}
emb_pca = adata$obsm['X_pca'] #extract pca embedding 
plot(emb_pca, col = cell.cols, pch=16, xlab = "PC1", ylab = "PC2", xlim = c(-15,20))
legend(x=10, y=6, legend = levels(clusters), col = col, pch = 16)

emb_umap = adata$obsm['X_umap'] #extract umap embedding 
plot(emb_umap, col = cell.cols, pch=16, xlab = "UMAP X", ylab = "UMAP Y")
legend(x=10, y=0, legend = levels(clusters), col = col, pch = 16, cex = 0.7)

```

Run velocity  
```{r run velocity, eval = FALSE}
scv$tl$recover_dynamics(adata)
scv$tl$velocity(adata, mode = "dynamical")
scv$tl$velocity_graph(adata)
#scv$pl$velocity_embedding_stream(adata, basis = "umap", legend_fontsize = 12, title = '', smooth = 0.8, min_mass=4)
```

Run cellrank  
```{r run cellrank, eval = FALSE}
cr$tl$terminal_states(adata,cluster_key = 'clusters', weight_connectivities = 0.2)
#cr$pl$terminal_states(adata)
cr$tl$initial_states(adata, cluster_key = 'clusters')
#cr$pl$initial_states(adata, discrete = TRUE)
```

Save adata to speed up later  
```{r save, eval=FALSE}
#py_save_object(adata, filename = "./saved_objects/cellrank_panc_adata.rds")
#adata = py_load_object("./saved_objects/cellrank_panc_adata.rds")

```


Extract transition matrices  
```{r transition matrices, fig.width=7, fig.height=6, fig.width = 4}
ck = cr$tl$kernels$ConnectivityKernel(adata) #connectivity kernel
vk = cr$tl$kernels$VelocityKernel(adata) #velocity kernel

ck$compute_transition_matrix() #compute connectivity transition matrix
vk$compute_transition_matrix() #velocity transition matrix

ctm = ck$transition_matrix #transition matrix - connectivities
vtm = vk$transition_matrix #transition matrix - velocities

tm_combined = (0.8*vtm) + (0.2*ctm) #weighted average of velocity and connectivity transition matrices

# sum(ctm>0)
# sum(vtm>0)
# sum(tm_combined>0)
# par(mfrow = c(3,1))
# hist(as.numeric(ctm[which(ctm>0)]), breaks = 500, main = "Connectivities \nTransition Probabilities")
# hist(as.numeric(vtm[which(vtm>0)]), breaks = 500, main = "Velocities \nTransition Probabilities")
# hist(as.numeric(tm_combined[which(tm_combined>0)]), breaks = 500, main = "Averaged \nTransition Probabilities")

```


Weighted graphs from transition matrices  
adjacency = transition matrix --> fdg  
Distances: transition matrix using just euclidean similarity  
Velocities: transition matrix using just velocity correlation  
Combined: transition matrix = weighted average of distance and velocity  
(using default weight 0.8velocity + 0.2distance)
```{r comapring graph types, fig.width=7, fig.height=3}
par(mfrow = c(1,3))
cg = graph_from_adjacency_matrix(ctm, mode = "directed", weighted = TRUE)
set.seed(1)
cfdg = layout_with_fr(cg, dim = 2)
plot(cfdg, pch = 16, col = cell.cols, main = "distances")

vg = graph_from_adjacency_matrix(vtm, mode = "directed", weighted = TRUE)
set.seed(1)
vfdg = layout_with_fr(vg, dim = 2)
plot(vfdg, pch = 16, col = cell.cols, main = "velocities")

g = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
set.seed(100)
fdg = layout_with_fr(g, dim = 2)
plot(fdg, pch = 16, col = cell.cols, main = "combined")

g = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
set.seed(1)
fdg = layout_with_fr(g, dim = 2)
plot(fdg, pch = 16, col = cell.cols, main = "combined, seed = 1")

g = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
set.seed(30)
fdg = layout_with_fr(g, dim = 2)
plot(fdg, pch = 16, col = cell.cols, main = "combined, seed = 30")

g = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
set.seed(100)
fdg = layout_with_fr(g, dim = 2)
plot(fdg, pch = 16, col = cell.cols, main = "combined, seed = 100")



```

Varying weight in weighted average   
```{r different weights, fig.width=7, fig.height=9}
ws = c(0,0.25,0.5,0.75,0.8,1)

par(mfrow = c(3,2))
for (w in ws){
  
  tm_combined = (w*vtm) + ((1-w)*ctm) #weighted average of velocity and connectivity transition matrices
  g = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
  set.seed(1)
  fdg = layout_with_fr(g, dim = 2)
  plot(fdg, pch = 16, col = cell.cols, main = paste("weight = ",w))
  
}

```

## scVelo - missing intermediates  
Build graph with data where part of the trajectory is missing.  

load missing intermediate adata from previous run  
```{r load previous missing}
#adata.missing = py_load_object("./saved_objects/cellrank_panc_adata_missing_fev.rds") # missing Fev+
adata.missing = py_load_object("./saved_objects/cellrank_panc_adata_missing_ngnhigh.rds") # missing some beta
clusters.missing = adata.missing$obs$clusters #extract clusters 
cell.names.missing = as.vector(adata.missing$obs_names$values)
# col.missing = rainbow(length(levels(clusters.missing)),s = 0.8, v = 0.8) 
# cell.cols.missing = col[clusters.missing] #color according to cluster
# names(cell.cols.missing) = names(clusters.missing) = cell.names.missing
cell.cols.missing  = cell.cols[cell.names.missing]
```

load pancreas data  
```{r loading panc data for missing, message=FALSE, eval = FALSE}
adata.missing = cr$datasets$pancreas()
#scv$pl$scatter(adata,legend_loc = "lower left", size = 60)
scv$utils$show_proportions(adata.missing)

emb_pca = adata.missing$obsm['X_pca'] #extract pca embedding
emb_umap = adata.missing$obsm['X_umap'] #extract umap embedding
clusters = adata.missing$obs$clusters #extract clusters
rownames(emb_umap) = names(clusters) = adata.missing$obs_names$values

# col = rainbow(length(levels(clusters)),s = 0.8, v = 0.8)
# cell.cols = col[clusters] #color according to cluster
# names(cell.cols) = names(clusters)

#cell.cols.missing  = cell.cols[cell.names.missing]
```

```{r plot panc data on umap missing, included = FALSE, eval = FALSE}
plot(emb_pca, col = cell.cols, pch=16, xlab = "PC1", ylab = "PC2")
plot(emb_umap, col = cell.cols, pch=16, xlab = "UMAP X", ylab = "UMAP Y", xlim = c(-15,20))
legend(x=13, y=0, legend = levels(clusters), col = col, pch = 16, cex = 0.7)
```

```{r remove intermediates, included = FALSE, eval = FALSE}
int.to.remove = "Ngn3 high EP"
adata.missing = adata.missing[adata.missing$obs$clusters!=int.to.remove]

#removing some of beta
# cells.to.remove = adata.missing$obs_names$values[(adata.missing$obs$clusters=="Beta") & (emb_umap[,1]>(-8))]
# adata.missing = adata.missing[!(adata$obs_names$values %in% cells.to.remove)]

emb_pca = adata.missing$obsm['X_pca'] #extract pca embedding
emb_umap = adata.missing$obsm['X_umap'] #extract umap embedding
clusters.missing = adata.missing$obs$clusters #extract clusters
cell.names.missing = adata.missing$obs_names$values
rownames(emb_umap) = names(clusters.missing) = cell.names.missing

# col.missing = rainbow(length(levels(clusters.missing)),s = 0.8, v = 0.8)
# cell.cols.missing = col[clusters.missing] #color according to cluster
# names(cell.cols.missing) = names(clusters.missing)
cell.cols.missing  = cell.cols[cell.names.missing]

plot(emb_pca, col = cell.cols.missing, pch=16, xlab = "PC1", ylab = "PC2")
plot(emb_umap, col = cell.cols.missing, pch=16, xlab = "UMAP X", ylab = "UMAP Y", xlim = c(-15,20))
legend(x=13, y=0, legend = levels(clusters), col = col, pch = 16, cex = 0.7)

```

```{r}
emb_umap = adata.missing$obsm['X_umap'] #extract umap embedding
rownames(emb_umap) = cell.names.missing

plot(emb_umap, col = cell.cols.missing, pch=16, xlab = "UMAP X", ylab = "UMAP Y", xlim = c(-15,20))
legend(x=13, y=0, legend = levels(clusters.missing), col = col, pch = 16, cex = 0.7)

#### Fev+ missing 
## cells before gap 
# x = emb_umap[,1]
# y = emb_umap[,2]
# cells.before.gap <- rownames(emb_umap)[x < 7 & x > 3.5]
# points(emb_umap[cells.before.gap,], col='black', pch = 15)
# ## cells after gap
# cells.after.gap <- rownames(emb_umap)[(x > (-5) & x < 3.5) & (y > -1)]
# points(emb_umap[cells.after.gap,], col='blue', pch = 15)
# legend(x=0, y=5, legend = c("before", "after"), col = c("black","blue"), pch = 15, cex = 0.7)


#### Ngn high missing
x = emb_umap[,1]
y = emb_umap[,2]
cells.before.gap <- rownames(emb_umap)[y > 6.1]
points(emb_umap[cells.before.gap,], col='black', pch = 15)
## cells after gap
cells.after.gap <- rownames(emb_umap)[x > 2 & y < 6 & y > (-1)]
points(emb_umap[cells.after.gap,], col='blue', pch = 15)
legend(x=7, y=5, legend = c("before", "after"), col = c("black","blue"), pch = 15, cex = 0.7)


#### Some beta missing
## cells before gap 
# x = emb_umap[,1]
# y = emb_umap[,2]
# cells.before.gap <- rownames(emb_umap)[x < (-2) & x > (-5) & y > 0]
# points(emb_umap[cells.before.gap,], col='black', pch = 15)
# ## cells after gap
# cells.after.gap <- rownames(emb_umap)[(x > (-10) & x < -7) & (y > -2)]
# points(emb_umap[cells.after.gap,], col='blue', pch = 15)
# legend(x=-8, y=7, legend = c("before", "after"), col = c("black","blue"), pch = 15, cex = 0.7)
```


Run scVelo 
```{r filter normalize log transform missing, eval = FALSE}
scv$pp$filter_and_normalize(adata.missing, min_shared_counts = as.integer(20), n_top_genes = as.integer(2000))
sc$tl$pca(adata.missing)
sc$pp$neighbors(adata.missing, n_pcs = as.integer(30), n_neighbors = as.integer(30))
scv$pp$moments(adata.missing, n_pcs = 30, n_neighbors = 30)

adata.missing
```

```{r plot missing, eval = FALSE}
emb_pca = adata.missing$obsm['X_pca'] #extract pca embedding 
plot(emb_pca, col = cell.cols.missing, pch=16, xlab = "PC1", ylab = "PC2", xlim = c(-15,20))
legend(x=10, y=6, legend = levels(clusters), col = col, pch = 16)

emb_umap = adata.missing$obsm['X_umap'] #extract umap embedding 
plot(emb_umap, col = cell.cols.missing, pch=16, xlab = "UMAP X", ylab = "UMAP Y")
legend(x=7, y=0, legend = levels(clusters), col = col, pch = 16, cex = 0.7)

```

Run velocity  
```{r run velocity missing, eval = FALSE}
scv$tl$recover_dynamics(adata.missing)
scv$tl$velocity(adata.missing, mode = "dynamical")
scv$tl$velocity_graph(adata.missing)
scv$pl$velocity_embedding_stream(adata.missing, basis = "umap", legend_fontsize = 12, title = '', smooth = 0.8, min_mass=4)
```
Run cellrank  
```{r run cellrank missing, eval = FALSE}
cr$tl$terminal_states(adata.missing,cluster_key = 'clusters', weight_connectivities = 0.2)
cr$pl$terminal_states(adata.missing)
cr$tl$initial_states(adata.missing, cluster_key = 'clusters')
cr$pl$initial_states(adata.missing, discrete = TRUE)

#not sure why this doesn't seem to work when missing ngn high 
```

Save adata to speed up later  
```{r save missing, eval=FALSE}
# py_save_object(adata.missing, filename = "./saved_objects/cellrank_panc_adata_missing_ngnhigh.rds")
# adata.missing2 = py_load_object("./saved_objects/cellrank_panc_adata_missing_ngnhigh.rds")

```

Extract transition matrices  
(cell rank doesn't work for missing Ngn High)  
```{r transition matrices missing, fig.width=7, fig.height=6, fig.width = 4, eval=FALSE}
ck.missing = cr$tl$kernels$ConnectivityKernel(adata.missing) #connectivity kernel
vk.missing = cr$tl$kernels$VelocityKernel(adata.missing) #velocity kernel

ck.missing$compute_transition_matrix() #compute connectivity transition matrix
vk.missing$compute_transition_matrix() #velocity transition matrix

ctm.missing = ck.missing$transition_matrix #transition matrix - connectivities
vtm.missing = vk.missing$transition_matrix #transition matrix - velocities

tm_combined.missing = (0.8*vtm.missing) + (0.2*ctm.missing) #weighted average of velocity and connectivity transition matrices

# sum(ctm.missing>0)
# sum(vtm.missing>0)
# sum(tm_combined.missing>0)
# par(mfrow = c(3,1))
# hist(as.numeric(ctm.missing[which(ctm.missing>0)]), breaks = 500, main = "Connectivities Transition \nProbabilities: Missing Fev+")
# hist(as.numeric(vtm.missing[which(vtm.missing>0)]), breaks = 500, main = "Velocities Transition \nProbabilities: Missing Fev+ ")
# hist(as.numeric(tm_combined.missing[which(tm_combined.missing>0)]), breaks = 500, main = "Averaged Transition \nProbabilities: Missing Fev+")

```

Weighted graphs from transition matrices  
adjacency = transition matrix --> fdg  
Distances: transition matrix using just euclidean similarity  
Velocities: transition matrix using just velocity correlation  
Combined: transition matrix = weighted average of distance and velocity  
(using default weight 0.8velocity + 0.2distance)
```{r comapring graph types missing, fig.width=7, fig.height=3, eval = FALSE}
par(mfrow = c(1,3))
cg.missing = graph_from_adjacency_matrix(ctm.missing, mode = "directed", weighted = TRUE)
set.seed(1)
cfdg.missing = layout_with_fr(cg.missing, dim = 2)
plot(cfdg.missing, pch = 16, col = cell.cols.missing, main = "distances")

vg.missing = graph_from_adjacency_matrix(vtm.missing, mode = "directed", weighted = TRUE)
set.seed(1)
vfdg.missing = layout_with_fr(vg.missing, dim = 2)
plot(vfdg.missing, pch = 16, col = cell.cols.missing, main = "velocities")

g.missing = graph_from_adjacency_matrix(tm_combined.missing, mode = "directed", weighted = TRUE)
set.seed(100)
fdg.missing = layout_with_fr(g.missing, dim = 2)
plot(fdg.missing, pch = 16, col = cell.cols.missing, main = "combined")

g.missing = graph_from_adjacency_matrix(tm_combined.missing, mode = "directed", weighted = TRUE)
set.seed(1)
fdg.missing = layout_with_fr(g.missing, dim = 2)
plot(fdg.missing, pch = 16, col = cell.cols.missing, main = "combined, seed = 1")

g.missing = graph_from_adjacency_matrix(tm_combined.missing, mode = "directed", weighted = TRUE)
set.seed(30)
fdg.missing = layout_with_fr(g.missing, dim = 2)
plot(fdg.missing, pch = 16, col = cell.cols.missing, main = "combined, seed = 30")

g.missing = graph_from_adjacency_matrix(tm_combined.missing, mode = "directed", weighted = TRUE)
set.seed(100)
fdg.missing = layout_with_fr(g.missing, dim = 2)
plot(fdg.missing, pch = 16, col = cell.cols.missing, main = "combined, seed = 100")



```

Varying weight in weighted average   
```{r different weights missing, fig.width=7, fig.height=9, eval = FALSE}
ws = c(0,0.25,0.5,0.75,0.8,1)

par(mfrow = c(3,2))
for (w in ws){
  
  tm_combined = (w*vtm.missing) + ((1-w)*ctm.missing) #weighted average of velocity and connectivity transition matrices
  g = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
  set.seed(1)
  fdg = layout_with_fr(g, dim = 2)
  plot(fdg, pch = 16, col = cell.cols.missing, main = paste("weight = ",w))
  
}



```


## veloViz - whole trajectory 
Extract count data..  
```{r extract counts, message = FALSE, results='hide', included = FALSE}
spliced = as.matrix(t(adata$layers['spliced']))
unspliced = as.matrix(t(adata$layers['unspliced']))
cells = adata$obs_names$values
genes = adata$var_names$values
clusters.velo = adata$obs$clusters #extract clusters 
colnames(spliced) = colnames(unspliced) = cells
rownames(spliced) = rownames(unspliced) = genes
```

```{r, fig.show = 'hide', eval = FALSE}
mns = rowMeans(spliced)
sds = sapply(c(1:nrow(spliced)), function(x) sd(spliced[x,]))
mnu = rowMeans(unspliced)
sdu = sapply(c(1:nrow(unspliced)), function(x) sd(unspliced[x,]))

par(mfrow = c(2,2))
hist(log10(mns+1), breaks = 500, main = "log10(mean gene expression) spliced")
hist(log10(mnu+1), breaks = 500, main = "log10(mean gene expression) unspliced")
plot(log10(mns+1),log10(sds+1), main = "log10(Std Dev) vs \nlog10(mean gene expression) spliced")
plot(log10(mnu+1),log10(sds+1), main = "log10(Std Dev) vs \nlog10(mean gene expression) unspliced")


```

Filter genes  
```{r filter genes, message = FALSE , included = FALSE, fig.show = 'hide'}
gexpS = log10(rowSums(spliced)+1)
gexpU = log10(rowSums(unspliced)+1)
plot(gexpS,gexpU)
# use same genes 
# goodGenes = genes[gexpS > 1 & gexpU > 1]
# spliced = spliced[goodGenes,]
# unspliced = unspliced[goodGenes,]
```

(Downsample cells to make things easier)  
```{r downsample, results='hide', included = FALSE}
spliced.sub = spliced[,seq(1,ncol(spliced),by=1)]
cell.names.pca = colnames(spliced.sub)
unspliced.sub = unspliced[,seq(1,ncol(unspliced),by=1)]
#cell.dist.sub = as.dist(1-cor(t(pcs[seq(1,ncol(unspliced),by=3),])))
cell.cols.sub = cell.cols[colnames(spliced.sub)]
```

Normalize for dimensional reduction  
```{r normalize, results='hide', included = FALSE}
allExp = spliced.sub + unspliced.sub #use combined spliced and unspliced counts 
#all.cpm = MUDAN::normalizeCounts(allExp) #cpm normalize - already normalized from scvelo? 
all.norm = MUDAN::normalizeVariance(allExp,details = TRUE, plot = FALSE) #variance stabilize 
odsGenes = rownames(allExp)[all.norm$ods] #overdispersed genes
all.logODS = as.matrix(t(all.norm$mat[all.norm$ods,])) #keep overdispersed genes 
```

```{r fig.width=5, fig.show = 'hide', eval = FALSE}
#look at distribution of gene expression
mna = rowMeans(allExp)
sda = sapply(c(1:nrow(allExp)), function(x) sd(allExp[x,]))
#mnc = rowMeans(all.cpm)
#sdc = sapply(c(1:nrow(all.cpm)), function(x) sd(all.cpm[x,]))
mnv = rowMeans(all.norm$mat)
sdv = sapply(c(1:nrow(all.norm$mat)), function(x) sd(all.norm$mat[x,]))
mno = colMeans(all.logODS)
sdo = sapply(c(1:ncol(all.logODS)), function(x) sd(all.logODS[,x]))

par(mfrow = c(2,3))
hist(log10(mna+1), breaks = 500, main = "log10(mean gene exp)")
#hist(log10(mnc+1), breaks = 500, main = "log10(mean gene normalized)")
hist(mnv, breaks = 500, main = "mean gene exp variance stabilized")
hist(mno, breaks = 500, main = "mean gene exp overdispersed")
plot(log10(mna+1),log10(sda+1), main = "log10(Std Dev) vs \nlog10(mean gene exp)")
#plot(log10(mnc+1),log10(sdc+1), main = "log10(Std Dev) vs \nlog10(mean gene normalized)")
plot(mnv,sdv, main = "Std Dev vs \nmean gene exp variance stabilized")
plot(mno,sdo, main = "Std Dev vs mean \ngene exp overdispersed")

#all.logODS ~normal, no mean-variance dependence --> pca 
```

Dimensional reduction  
```{r dimensional reduction, included = FALSE, fig.show = 'hide'}
pca = svds(A = all.logODS, k=50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var = pca$d
plot(var) # ~10 components 

emb.pca = pca$u[,1:2]
row.names(emb.pca) = row.names(all.logODS)
plot(emb.pca, col = cell.cols, pch = 16, xlab = "PC1", ylab = "PC2", main = "PCA")


#pairwise cell dists for velocity calculation 
cell.dist = as.dist(1-cor(t(pca$u)))
```


Run velocyto on panc data  
```{r velocity, message = FALSE, results = 'hide', included = FALSE}
#vel = gene.relative.velocity.estimates(spliced.sub,unspliced.sub,deltaT=1,kCells=30,cell.dist=cell.dist,fit.quantile=0.1,mult=100)
#saveRDS(vel,file = "panc_vel_cellrank.rds")
vel = readRDS("/Users/lylaatta/OneDrive - Johns Hopkins/Johns Hopkins/ComputerTransfer/veloviz_largefiles/saved_objects/panc_vel_cellrank.rds")
curr = vel$current
proj = vel$projected

#show velocity on PCA
# show.velocity.on.embedding.cor(scale(emb.pca), vel, n=100, scale='sqrt', cell.colors=cell.cols.sub,cex=1, arrow.scale=1, show.grid.flow=TRUE,min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2, main = "Velocities on PCA embedding")

# #show velocity on UMAP 
# emb.umap.sub = emb_umap[rownames(emb.pca),]
# show.velocity.on.embedding.cor(scale(emb.umap.sub), vel, n=100, scale='sqrt', cell.colors=cell.cols.sub,cex=1, arrow.scale=1, show.grid.flow=TRUE,min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2, main = "Velocities on UMAP embedding")

```  

```{r, fig.show = 'hide', eval = FALSE}
#look at gene exp distribution in curr and proj

par(mfrow = c(2,2))
currmeans = log10(rowMeans(curr)+1)
currsds = log10(sapply(c(1:nrow(curr)), function(x) sd(curr[x,]))+1)
hist(currmeans,breaks = 500, main = "curr: log mean gene exp")
plot(currmeans,currsds, main = "curr: log means vs log sds")

projmeans = log10(rowMeans(proj)+1)
projsds = log10(sapply(c(1:nrow(proj)), function(x) sd(proj[x,]))+1)
hist(projmeans,breaks = 500, main = "proj: log mean gene exp")
plot(projmeans,projsds, main = "proj: log means vs log sds")

curr.norm.df = MUDAN::normalizeVariance(curr,details = TRUE, plot = FALSE) #variance stabilize 
curr.norm = curr.norm.df$mat
proj.norm = MUDAN::normalizeVariance(proj,details = FALSE, plot = FALSE) #variance stabilize 
proj.norm.new = proj*curr.norm.df$df$gsf

par(mfrow = c(2,2))
curr.norm.means = log10(rowMeans(curr.norm)+1)
curr.norm.sds = log10(sapply(c(1:nrow(curr.norm)), function(x) sd(curr.norm[x,]))+1)
hist(curr.norm.means, breaks = 500)
plot(curr.norm.means, curr.norm.sds)

proj.norm.means = log10(rowMeans(proj.norm)+1)
proj.norm.sds = log10(sapply(c(1:nrow(proj.norm)), function(x) sd(proj.norm[x,]))+1)
hist(proj.norm.means, breaks = 500)
plot(proj.norm.means, proj.norm.sds)

proj.norm.means = log10(rowMeans(proj.norm.new)+1)
proj.norm.sds = log10(sapply(c(1:nrow(proj.norm.new)), function(x) sd(proj.norm.new[x,]))+1)
hist(proj.norm.means, breaks = 500)
plot(proj.norm.means, proj.norm.sds)

#curr.norm and proj.norm ~normal and no mean-variance dependence --> pca 

```

```{r, results = 'hide'}
curr.norm.df = MUDAN::normalizeVariance(curr,details = TRUE, plot = FALSE) #variance stabilize 
curr.norm = curr.norm.df$mat
proj.norm = proj*curr.norm.df$df$gsf

pca.velo = svds(A = t(curr.norm), k=50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var = pca.velo$d
#plot(var) # ~10 components 

emb.pca.velo = pca.velo$u[,1:2]
row.names(emb.pca.velo) = colnames(curr.norm)
plot(emb.pca.velo, col = cell.cols, pch = 16, xlab = "PC1", ylab = "PC2", main = "PCA")


```


Scores of observed and projected states in PC space  
```{r pc scores, included = FALSE,  fig.width = 7}
u = pca.velo$u #scores
v = pca.velo$v #loads
row.names(v) = rownames(curr.norm)

common.genes = sapply(row.names(curr.norm), function(x) x %in% odsGenes)
common.genes.names = rownames(curr.norm)[common.genes]
curr.pca = curr.norm[common.genes,]
v.sub = v[row.names(curr.pca),]

par(mfrow = c(1,2))
curr.scores = scale(t(curr.pca), scale = FALSE) %*% v.sub
plot(curr.scores[,1:2], col = cell.cols, main = 'Observed')#,xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))

proj.pca = proj.norm[common.genes,]
proj.scores = scale(t(proj.pca), scale = FALSE) %*% v.sub
plot(proj.scores[,1:2], col = cell.cols, main = 'Projected')#,xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))

```

Graph visualization on subset of cells from PC coordinates  
```{r graph viz from PCs, results = "hide", fig.height=8, fig.width = 8}
ws = c(0.1,1,10,25,50,100)
par(mfrow = c(3,2))
for (w in ws){
  set.seed(1)
  vizg = graphViz(t(curr.scores), t(proj.scores), k=30, distance_metric = "L2", similarity_metric = "cosine", distance_weight = w, similarity_threshold = 0, weighted = TRUE, cell.colors = cell.cols,plot = TRUE, return_graph = TRUE,title = paste("Weight = ", w))
}


```

## veloViz - missing intermediates  
Extract count data..  
```{r extract counts missing, message = FALSE, results='hide', included = FALSE}
spliced.missing = as.matrix(t(adata.missing$layers['spliced']))
unspliced.missing = as.matrix(t(adata.missing$layers['unspliced']))
cells.missing = adata.missing$obs_names$values
genes.missing = adata.missing$var_names$values
colnames(spliced.missing) = colnames(unspliced.missing) = cells.missing
rownames(spliced.missing) = rownames(unspliced.missing) = genes.missing
```

Filter genes  
```{r filter genes missing, message = FALSE , included = FALSE, fig.show = 'hide', eval = FALSE}
gexpS.missing = log10(rowSums(spliced.missing)+1)
gexpU.missing = log10(rowSums(unspliced.missing)+1)
plot(gexpS.missing,gexpU.missing)
# use same genes 
# goodGenes = genes[gexpS > 1 & gexpU > 1]
# spliced = spliced[goodGenes,]
# unspliced = unspliced[goodGenes,]
```

(Downsample cells to make things easier)  
```{r downsample missing, results='hide', included = FALSE}
spliced.missing.sub = spliced.missing[,seq(1,ncol(spliced.missing),by=1)]
cell.names.pca.missing = colnames(spliced.missing.sub)
unspliced.missing.sub = unspliced.missing[,seq(1,ncol(unspliced.missing),by=1)]
#cell.dist.sub = as.dist(1-cor(t(pcs[seq(1,ncol(unspliced),by=3),])))
cell.cols.missing.sub = cell.cols[colnames(spliced.missing.sub)]
```

Normalize for dimensional reduction  
```{r normalize missing, results='hide', included = FALSE}
allExp.missing = spliced.missing.sub + unspliced.missing.sub #use combined spliced and unspliced counts 
#all.cpm = MUDAN::normalizeCounts(allExp) #cpm normalize - already normalized from scvelo? 
all.norm.missing = MUDAN::normalizeVariance(allExp.missing,details = TRUE, plot = FALSE) #variance stabilize 
odsGenes.missing = rownames(allExp.missing)[all.norm.missing$ods] #overdispersed genes
all.logODS.missing = as.matrix(t(all.norm.missing$mat[all.norm.missing$ods,])) #keep overdispersed genes 
```

Dimensional reduction  
```{r dimensional reduction missing, included = FALSE, fig.show = 'hide'}
pca.missing = svds(A = all.logODS.missing, k=50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var.missing = pca.missing$d
plot(var.missing) # ~10 components 

emb.pca.missing = pca.missing$u[,1:2]
row.names(emb.pca.missing) = row.names(all.logODS.missing)
plot(emb.pca.missing, col = cell.cols.missing, pch = 16, xlab = "PC1", ylab = "PC2", main = "PCA")
legend(x=-0.02, y=-0.03, legend = levels(clusters), col = col, pch = 16, cex = 0.7)


#pairwise cell dists for velocity calculation 
cell.dist.missing = as.dist(1-cor(t(pca.missing$u)))

```

Run velocyto on panc data  
```{r velocity missing, message = FALSE, results = 'hide', included = FALSE}
# vel.missing = gene.relative.velocity.estimates(spliced.missing.sub,unspliced.missing.sub,deltaT=1,kCells=30,
#                                                cell.dist=cell.dist.missing,fit.quantile=0.1,mult=100)
# saveRDS(vel.missing,file = "./saved_objects/panc_vel_cellrank_missing_ngnhigh.rds")

#vel.missing = readRDS("./saved_objects/panc_vel_cellrank_missing_fev.rds")
#vel.missing = readRDS("./saved_objects/panc_vel_cellrank_missing_somebeta.rds")
vel.missing = readRDS("./saved_objects/panc_vel_cellrank_missing_ngnhigh.rds")
curr.missing = vel.missing$current
proj.missing = vel.missing$projected

#show velocity on PCA
# show.velocity.on.embedding.cor(scale(emb.pca), vel, n=100, scale='sqrt', cell.colors=cell.cols.sub,cex=1, arrow.scale=1, show.grid.flow=TRUE,min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2, main = "Velocities on PCA embedding")

# #show velocity on UMAP 
# emb.umap.sub = emb_umap[rownames(emb.pca),]
# show.velocity.on.embedding.cor(scale(emb.umap.sub), vel, n=100, scale='sqrt', cell.colors=cell.cols.sub,cex=1, arrow.scale=1, show.grid.flow=TRUE,min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2, main = "Velocities on UMAP embedding")

```  

```{r, results = 'hide'}
curr.missing.norm.df = MUDAN::normalizeVariance(curr.missing,details = TRUE, plot = FALSE) #variance stabilize 
curr.norm.missing = curr.missing.norm.df$mat
proj.norm.missing = proj.missing*curr.missing.norm.df$df$gsf

pca.velo.missing = svds(A = t(curr.norm.missing), k=50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var.velo.missing = pca.velo.missing$d
#plot(var) # ~10 components 

emb.pca.velo.missing = pca.velo.missing$u[,1:2]
row.names(emb.pca.velo.missing) = colnames(curr.norm.missing)
plot(emb.pca.velo.missing, col = cell.cols.missing, pch = 16, xlab = "PC1", ylab = "PC2", main = "PCA")
legend(x=-0.02, y=0.08, legend = levels(clusters), col = col, pch = 16, cex = 0.7)


```

Scores of observed and projected states in PC space  
```{r pc scores missing, included = FALSE,  fig.width = 7}
u.missing = pca.velo.missing$u #scores
v.missing = pca.velo.missing$v #loads
row.names(v.missing) = rownames(curr.norm.missing)

common.genes.missing = sapply(row.names(curr.norm.missing), function(x) x %in% odsGenes.missing)
common.genes.names.missing = rownames(curr.norm.missing)[common.genes.missing]
curr.pca.missing = curr.norm.missing[common.genes.names.missing,]
v.sub.missing = v.missing[row.names(curr.pca.missing),]

par(mfrow = c(1,2))
curr.scores.missing = scale(t(curr.pca.missing), scale = FALSE) %*% v.sub.missing
plot(curr.scores.missing[,1:2], pch = 16, col = cell.cols.missing, main = 'Observed')#,xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))
legend(x=-5, y=20, legend = levels(clusters), col = col, pch = 16, cex = 0.7)

proj.pca.missing = proj.norm.missing[common.genes.missing,]
proj.scores.missing = scale(t(proj.pca.missing), scale = FALSE) %*% v.sub.missing
plot(proj.scores.missing[,1:2], pch = 16, col = cell.cols.missing, main = 'Projected')#,xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))
legend(x=-5, y=20, legend = levels(clusters), col = col, pch = 16, cex = 0.7)

```

Graph visualization from PC coordinates  
```{r graph viz from PCs missing, results = "hide", fig.height=8, fig.width = 8}
ws = c(0.1,1,5,10,15,17,20,25)
par(mfrow = c(4,2))
for (w in ws){
  set.seed(1)
  vizg = graphViz(t(curr.scores.missing), t(proj.scores.missing), k=30, distance_metric = "L2", similarity_metric = "cosine", distance_weight = w, similarity_threshold = 0, weighted = TRUE, cell.colors = cell.cols.missing,plot = TRUE, return_graph = TRUE,title = paste("Weight = ", w))
}


```


## Changing veloviz parameters  
Above, I used k=30 for direct comparison to cellRank graph which computes distances to K=30 nearest neighbors uses. However, this might not be where veloviz performs best.  
```{r, results = "hide", fig.height=8, fig.width = 8}
ks = c(5,10,20,30,50,100)
par(mfrow = c(3,2))
for (k in ks){
  set.seed(1)
  vizg = graphViz(t(curr.scores.missing), t(proj.scores.missing), k=k, 
                  distance_metric = "L2", similarity_metric = "cosine", distance_weight = 1, similarity_threshold = 0, weighted = TRUE, 
                  cell.colors = cell.cols.missing, plot = TRUE, return_graph = TRUE,title = paste("K = ", k))
}
```


## Comparing graphs  
```{r, results = 'hide', fig.height=6, fig.width = 6}
par(mfrow = c(1,2))

# w = 0.8
# tm_combined = (w*vtm.missing) + ((1-w)*ctm.missing) #weighted average of velocity and connectivity transition matrices
# rankg = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
# set.seed(1)
# rank.fdg = layout_with_fr(rankg, dim = 2)
# rownames(rank.fdg) = cell.names.missing
# plot(rank.fdg, pch = 16, col = cell.cols.missing, main = paste("cellRank: weight = ",w,"\ndefault params"), cex = 0.5)

set.seed(1)
k = 30
vizg = graphViz(t(curr.scores.missing), t(proj.scores.missing), k=k,
                distance_metric = "L2", similarity_metric = "cosine", distance_weight = 1, similarity_threshold = 0, weighted = TRUE, 
                cell.colors = cell.cols.missing, plot = FALSE, return_graph = TRUE,title = paste("veloViz: K = ", k))
viz.fdg = vizg$fdg_coords
rownames(viz.fdg) = cell.names.missing
plot(viz.fdg, pch = 16, col = cell.cols.missing, main = paste("veloViz: K = ", k,"\ndirect comparison"), cex = 0.5)
# 
# w = 0.5
# tm_combined = (w*vtm.missing) + ((1-w)*ctm.missing) #weighted average of velocity and connectivity transition matrices
# rankg = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
# set.seed(1)
# rank.fdg = layout_with_fr(rankg, dim = 2)
# rownames(rank.fdg) = cell.names.missing
# plot(rank.fdg, pch = 16, col = cell.cols.missing, main = paste("cellRank: weight = ",w), cex = 0.5)

set.seed(1)
k = 20
vizg = graphViz(t(curr.scores.missing), t(proj.scores.missing), k=k,
                distance_metric = "L2", similarity_metric = "cosine", distance_weight = 1, similarity_threshold = 0, weighted = TRUE, 
                cell.colors = cell.cols.missing, plot = FALSE, return_graph = TRUE,title = paste("veloViz: K = ", k))
viz.fdg = vizg$fdg_coords
rownames(viz.fdg) = cell.names.missing
plot(viz.fdg, pch = 16, col = cell.cols.missing, main = paste("veloViz: K = ", k), cex = 0.5)



```


Compare mean distance between cells before and after the gap normalized by max distance between any two cells for each graph.  
Comparing default cellRank graph to veloViz graph  
```{r, results = 'hide'}
# #"default" parameters and direct comparison
# par(mfrow = c(1,2))
# w = 0.8
# tm_combined = (w*vtm.missing) + ((1-w)*ctm.missing) #weighted average of velocity and connectivity transition matrices
# rankg = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
# set.seed(1)
# rank.fdg = layout_with_fr(rankg, dim = 2)
# rownames(rank.fdg) = cell.names.missing
# plot(rank.fdg, pch = 16, col = cell.cols.missing, main = paste("cellRank: weight = ",w,"\ndefault params"), cex = 0.5)
# points(rank.fdg[cells.before.gap,], pch = 4, col = "black",cex = 0.5)
# points(rank.fdg[cells.after.gap,], pch = 4, col = "blue",cex = 0.5)
# 
# #mean before location
# rank.before.x = mean(rank.fdg[cells.before.gap,1])
# rank.before.y = mean(rank.fdg[cells.before.gap,2])
# points(rank.before.x,rank.before.y, pch = 15, col = "red", cex = 1.5)
# #mean after location
# rank.after.x = mean(rank.fdg[cells.after.gap,1])
# rank.after.y = mean(rank.fdg[cells.after.gap,2])
# points(rank.after.x,rank.after.y, pch = 15, col = "red", cex = 1.5)
# 
# #distance between before and after
# rank.points = matrix(c(rank.before.x,rank.after.x,rank.before.y,rank.after.y),ncol = 2)
# rank.dist = dist(rank.points) #idk if it makes sense to compare these two distances - they're on different scales? 
# #normalize by max distance between two cells? 
# rank.max.dist = max(dist(rank.fdg))
# rank.norm.dist = rank.dist/rank.max.dist
# text(mean(c(rank.before.x,rank.after.x)),mean(c(rank.before.y,rank.after.y)),labels = formatC(rank.norm.dist,digits = 3), col = 'red')


set.seed(1)
k = 30
vizg = graphViz(t(curr.scores.missing), t(proj.scores.missing), k=k,
                distance_metric = "L2", similarity_metric = "cosine", distance_weight = 1, similarity_threshold = 0, weighted = TRUE, 
                cell.colors = cell.cols.missing, plot = FALSE, return_graph = TRUE,title = paste("veloViz: K = ", k))
viz.fdg = vizg$fdg_coords
rownames(viz.fdg) = cell.names.missing
plot(viz.fdg, pch = 16, col = cell.cols.missing, main = paste("veloViz: K = ", k,"\ndirect comparison"), cex = 0.5)
points(viz.fdg[cells.before.gap,], pch = 4, col = "black",cex = 0.5)
points(viz.fdg[cells.after.gap,], pch = 4, col = "blue",cex = 0.5)

#mean before location
viz.before.x = mean(viz.fdg[cells.before.gap,1])
viz.before.y = mean(viz.fdg[cells.before.gap,2])
points(viz.before.x,viz.before.y, pch = 15, col = "red", cex = 1.5)
#mean after location
viz.after.x = mean(viz.fdg[cells.after.gap,1])
viz.after.y = mean(viz.fdg[cells.after.gap,2])
points(viz.after.x,viz.after.y, pch = 15, col = "red", cex = 1.5)

#distance between before and after
viz.points = matrix(c(viz.before.x,viz.after.x,viz.before.y,viz.after.y),nrow = 2)
viz.dist = dist(viz.points)
#normalize 
viz.max.dist = max(dist(viz.fdg))
viz.norm.dist = viz.dist/viz.max.dist
text(mean(c(viz.before.x,viz.after.x)),mean(c(viz.before.y,viz.after.y)),labels = formatC(viz.norm.dist,digits = 3), col = 'red')

```


Comparing 'best' cellRank graph (only velocity based) to 'best' veloViz graph (k = 10)  
```{r, results = 'hide'}
# par(mfrow = c(1,2))
# w = 0.5
# tm_combined = (w*vtm.missing) + ((1-w)*ctm.missing) #weighted average of velocity and connectivity transition matrices
# rankg = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
# set.seed(1)
# rank.fdg = layout_with_fr(rankg, dim = 2)
# rownames(rank.fdg) = cell.names.missing
# plot(rank.fdg, pch = 16, col = cell.cols.missing, main = paste("cellRank: weight = ",w), cex = 0.5)
# points(rank.fdg[cells.before.gap,], pch = 4, col = "black",cex = 0.5)
# points(rank.fdg[cells.after.gap,], pch = 4, col = "blue",cex = 0.5)
# 
# #mean before location
# rank.before.x = mean(rank.fdg[cells.before.gap,1])
# rank.before.y = mean(rank.fdg[cells.before.gap,2])
# points(rank.before.x,rank.before.y, pch = 15, col = "red", cex = 1.5)
# #mean after location
# rank.after.x = mean(rank.fdg[cells.after.gap,1])
# rank.after.y = mean(rank.fdg[cells.after.gap,2])
# points(rank.after.x,rank.after.y, pch = 15, col = "red", cex = 1.5)
# 
# #distance between before and after
# rank.points = matrix(c(rank.before.x,rank.after.x,rank.before.y,rank.after.y),ncol = 2)
# rank.dist = dist(rank.points) #idk if it makes sense to compare these two distances - they're on different scales? 
# #normalize by max distance between two cells? 
# rank.max.dist = max(dist(rank.fdg))
# rank.norm.dist = rank.dist/rank.max.dist
# text(mean(c(rank.before.x,rank.after.x)),mean(c(rank.before.y,rank.after.y)),labels = formatC(rank.norm.dist,digits = 3), col = 'red')


set.seed(1)
k = 20
vizg = graphViz(t(curr.scores.missing), t(proj.scores.missing), k=k,
                distance_metric = "L2", similarity_metric = "cosine", distance_weight = 1, similarity_threshold = 0, weighted = TRUE, 
                cell.colors = cell.cols.missing, plot = FALSE, return_graph = TRUE,title = paste("veloViz: K = ", k))
viz.fdg = vizg$fdg_coords
rownames(viz.fdg) = cell.names.missing
plot(viz.fdg, pch = 16, col = cell.cols.missing, main = paste("veloViz: K = ", k), cex = 0.5)
points(viz.fdg[cells.before.gap,], pch = 4, col = "black",cex = 0.5)
points(viz.fdg[cells.after.gap,], pch = 4, col = "blue",cex = 0.5)

#mean before location
viz.before.x = mean(viz.fdg[cells.before.gap,1])
viz.before.y = mean(viz.fdg[cells.before.gap,2])
points(viz.before.x,viz.before.y, pch = 15, col = "red", cex = 1.5)
#mean after location
viz.after.x = mean(viz.fdg[cells.after.gap,1])
viz.after.y = mean(viz.fdg[cells.after.gap,2])
points(viz.after.x,viz.after.y, pch = 15, col = "red", cex = 1.5)

#distance between before and after
viz.points = matrix(c(viz.before.x,viz.after.x,viz.before.y,viz.after.y),nrow = 2)
viz.dist = dist(viz.points)
#normalize 
viz.max.dist = max(dist(viz.fdg))
viz.norm.dist = viz.dist/viz.max.dist
text(mean(c(viz.before.x,viz.after.x)),mean(c(viz.before.y,viz.after.y)),labels = formatC(viz.norm.dist,digits = 3), col = 'red')

```



#### Comparing graphs from each method 
```{r compare consistiency scores, eval = FALSE}
#picking default weight for cellrank graph w = 0.8 
#picking default settings for composite distance, w=1, thresh=0
#k = 30 for both

tm_combined = (0.8*vtm) + ((1-0.8)*ctm) #weighted average of velocity and connectivity transition matrices
cr_graph = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
set.seed(1)
cr_fdg = layout_with_fr(cr_graph, dim = 2)
plot(cr_fdg, pch = 16, col = cell.cols, main = paste(paste("k = 30, weight = 0.8")))

set.seed(1)
viz_graph = graphViz(t(curr.scores), t(proj.scores), k=30, distance_metric = "L2", similarity_metric = "cosine", distance_weight = 1, similarity_threshold = 0, weighted = TRUE, cell.colors = cell.cols,plot = FALSE, return_graph = TRUE,title = paste("k = 30, weight = 1, t=0"))
viz_fdg = viz_graph$fdg_coords
plot(viz_fdg, pch = 16, col = cell.cols, main = paste(paste("k = 30, weight = 1, t=0")))

#extract velocities from each model 
cr_vel = as.matrix(adata$layers['velocity'])
rownames(cr_vel) = as.character(adata$obs_names$values)
colnames(cr_vel) = as.character(adata$var_names$values)
cr_vel = t(cr_vel)
cr_vel[is.nan(cr_vel)] = 0
viz_vel = vel$deltaE

#calculate consistency scores for each model 
cr_consistency = consistency(cr_fdg, cr_vel, 30, TRUE)
viz_consistency = consistency(viz_fdg, viz_vel, 30, TRUE)






neighbor.cors = pwiseCors(as.matrix(viz_vel),viz_consistency,30)


source("projectedNeighbors_weightedCD.R")


```










