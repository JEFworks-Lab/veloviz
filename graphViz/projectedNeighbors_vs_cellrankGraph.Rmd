---
title: "Comparing projectedNeighbors to graph from cell rank"
author: "LylaAtta"
date: "10/26/2020"
output:
  html_document: default
  pdf_document: default
---

cellRank builds a graph based on a transition matrix. The transition matrix contains the probabilities of cell-->cell transitions, which are calculated as a weighted average between (similarity of velocity vector and cell difference vector) and (euclidean similarity in PCA space). Here, we want to compare this graph to the graph that we build using projectedNeighbors. 

#### Setup and get data from scVelo
```{r setup, include=FALSE}
#using velocyto2 evironment 
knitr::opts_chunk$set(echo = FALSE)
library(reticulate)
library(igraph)
library(matie)
library(RANN)
library(velocyto.R)
library(MUDAN)
library(RSpectra)
library(umap)
library(Rcpp)
source("projectedNeighbors_weightedCD.R")
```

Use the reticulate package to use scVelo/cellrank from within R:   
```{r importing scvelo}
use_condaenv("cellrank",required = TRUE)
scv = import("scvelo")
sc = import("scanpy")
cr = import("cellrank")
np = import("numpy")
pk = import("pickle")
#scv$logging$print_version()
```

load complete adata from previous run  
```{r}
adata = py_load_object("./saved_objects/cellrank_panc_adata.rds")

clusters = adata$obs$clusters #extract clusters 
col = rainbow(length(levels(clusters)),s = 0.8, v = 0.8) 
cell.cols = col[clusters] #color according to cluster
names(cell.cols) = names(clusters)
```



load pancreas data  
```{r loading panc data, message=FALSE, eval = FALSE}
adata = cr$datasets$pancreas()
#scv$pl$scatter(adata,legend_loc = "lower left", size = 60)
scv$utils$show_proportions(adata)

emb_pca = adata$obsm['X_pca'] #extract pca embedding 
emb_umap = adata$obsm['X_umap'] #extract umap embedding 
clusters = adata$obs$clusters #extract clusters 
rownames(emb_umap) = names(clusters) = adata$obs_names$values

col = rainbow(length(levels(clusters)),s = 0.8, v = 0.8) 
cell.cols = col[clusters] #color according to cluster
names(cell.cols) = names(clusters)
```

```{r plot panc data on umap, included = FALSE, eval = FALSE}
plot(emb_pca, col = cell.cols, pch=16, xlab = "PC1", ylab = "PC2")
plot(emb_umap, col = cell.cols, pch=16, xlab = "UMAP X", ylab = "UMAP Y", xlim = c(-15,20))
legend(x=10, y=6, legend = levels(clusters), col = col, pch = 16)
```



#### Run scVelo 
```{r filter normalize log transform, eval = FALSE}
scv$pp$filter_and_normalize(adata, min_shared_counts = as.integer(20), n_top_genes = as.integer(2000))
sc$tl$pca(adata)
sc$pp$neighbors(adata, n_pcs = as.integer(30), n_neighbors = as.integer(30))
scv$pp$moments(adata, n_pcs = 30, n_neighbors = 30)

adata
```

```{r}
emb_pca = adata$obsm['X_pca'] #extract pca embedding 
plot(emb_pca, col = cell.cols, pch=16, xlab = "PC1", ylab = "PC2", xlim = c(-15,20))
legend(x=10, y=6, legend = levels(clusters), col = col, pch = 16)

emb_umap = adata$obsm['X_umap'] #extract umap embedding 
plot(emb_umap, col = cell.cols, pch=16, xlab = "UMAP X", ylab = "UMAP Y")
legend(x=10, y=6, legend = levels(clusters), col = col, pch = 16)

```

Run velocity  
```{r, eval = FALSE}
scv$tl$recover_dynamics(adata)
scv$tl$velocity(adata, mode = "dynamical")
scv$tl$velocity_graph(adata)
#scv$pl$velocity_embedding_stream(adata, basis = "umap", legend_fontsize = 12, title = '', smooth = 0.8, min_mass=4)
```

Run cellrank  
```{r, eval = FALSE}
cr$tl$terminal_states(adata,cluster_key = 'clusters', weight_connectivities = 0.2)
#cr$pl$terminal_states(adata)
cr$tl$initial_states(adata, cluster_key = 'clusters')
#cr$pl$initial_states(adata, discrete = TRUE)
```

Save adata to speed up later  
```{r}
#py_save_object(adata, filename = "./saved_objects/cellrank_panc_adata.rds")
#adata = py_load_object("./saved_objects/cellrank_panc_adata.rds")

```


Extract transition matrices  
```{r, fig.width=7, fig.height=6, fig.width = 4}
ck = cr$tl$kernels$ConnectivityKernel(adata) #connectivity kernel
vk = cr$tl$kernels$VelocityKernel(adata) #velocity kernel

ck$compute_transition_matrix() #compute connectivity transition matrix
vk$compute_transition_matrix() #velocity transition matrix

ctm = ck$transition_matrix #transition matrix - connectivities
vtm = vk$transition_matrix #transition matrix - velocities

tm_combined = (0.8*vtm) + (0.2*ctm) #weighted average of velocity and connectivity transition matrices

# sum(ctm>0)
# sum(vtm>0)
# sum(tm_combined>0)
par(mfrow = c(3,1))
hist(as.numeric(ctm[which(ctm>0)]), breaks = 500, main = "Connectivities \nTransition Probabilities")
hist(as.numeric(vtm[which(vtm>0)]), breaks = 500, main = "Velocities \nTransition Probabilities")
hist(as.numeric(tm_combined[which(tm_combined>0)]), breaks = 500, main = "Averaged \nTransition Probabilities")

```


Weighted graphs from transition matrices  
adjacency = transition matrix --> fdg  
Distances: transition matrix using just euclidean similarity  
Velocities: transition matrix using just velocity correlation  
Combined: transition matrix = weighted average of distance and velocity  
(using default weight 0.8velocity + 0.2distance)
```{r, fig.width=7, fig.height=3}
par(mfrow = c(1,3))
cg = graph_from_adjacency_matrix(ctm, mode = "directed", weighted = TRUE)
set.seed(1)
cfdg = layout_with_fr(cg, dim = 2)
plot(cfdg, pch = 16, col = cell.cols, main = "distances")

vg = graph_from_adjacency_matrix(vtm, mode = "directed", weighted = TRUE)
set.seed(1)
vfdg = layout_with_fr(vg, dim = 2)
plot(vfdg, pch = 16, col = cell.cols, main = "velocities")

g = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
set.seed(100)
fdg = layout_with_fr(g, dim = 2)
plot(fdg, pch = 16, col = cell.cols, main = "combined")

g = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
set.seed(1)
fdg = layout_with_fr(g, dim = 2)
plot(fdg, pch = 16, col = cell.cols, main = "combined, seed = 1")

g = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
set.seed(30)
fdg = layout_with_fr(g, dim = 2)
plot(fdg, pch = 16, col = cell.cols, main = "combined, seed = 30")

g = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
set.seed(100)
fdg = layout_with_fr(g, dim = 2)
plot(fdg, pch = 16, col = cell.cols, main = "combined, seed = 100")



```

Varying weight in weighted average   
```{r different weights, fig.width=7, fig.height=9}
ws = c(0,0.25,0.5,0.75,0.8,1)

par(mfrow = c(3,2))
for (w in ws){
  
  tm_combined = (w*vtm) + ((1-w)*ctm) #weighted average of velocity and connectivity transition matrices
  g = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
  set.seed(1)
  fdg = layout_with_fr(g, dim = 2)
  plot(fdg, pch = 16, col = cell.cols, main = paste("weight = ",w))
  
}



```


### Use composite distance 

Extract count data..  
```{r extract counts, message = FALSE, results='hide', included = FALSE}
spliced = as.matrix(t(adata$layers['spliced']))
unspliced = as.matrix(t(adata$layers['unspliced']))
cells = adata$obs_names$values
genes = adata$var_names$values
colnames(spliced) = colnames(unspliced) = cells
rownames(spliced) = rownames(unspliced) = genes
```

```{r, fig.show = 'hide'}
mns = rowMeans(spliced)
sds = sapply(c(1:nrow(spliced)), function(x) sd(spliced[x,]))
mnu = rowMeans(unspliced)
sdu = sapply(c(1:nrow(unspliced)), function(x) sd(unspliced[x,]))

par(mfrow = c(2,2))
hist(log10(mns+1), breaks = 500, main = "log10(mean gene expression) spliced")
hist(log10(mnu+1), breaks = 500, main = "log10(mean gene expression) unspliced")
plot(log10(mns+1),log10(sds+1), main = "log10(Std Dev) vs \nlog10(mean gene expression) spliced")
plot(log10(mnu+1),log10(sds+1), main = "log10(Std Dev) vs \nlog10(mean gene expression) unspliced")


```



Filter genes  
```{r filter genes, message = FALSE , included = FALSE, fig.show = 'hide'}
gexpS = log10(rowSums(spliced)+1)
gexpU = log10(rowSums(unspliced)+1)
plot(gexpS,gexpU)
# use same genes 
# goodGenes = genes[gexpS > 1 & gexpU > 1]
# spliced = spliced[goodGenes,]
# unspliced = unspliced[goodGenes,]
```

(Downsample cells to make things easier)  
```{r downsample, results='hide', included = FALSE}
spliced.sub = spliced[,seq(1,ncol(spliced),by=1)]
cell.names.pca = colnames(spliced.sub)
unspliced.sub = unspliced[,seq(1,ncol(unspliced),by=1)]
#cell.dist.sub = as.dist(1-cor(t(pcs[seq(1,ncol(unspliced),by=3),])))
cell.cols.sub = cell.cols[colnames(spliced.sub)]
```

Normalize for dimensional reduction  
```{r normalize, results='hide', included = FALSE}
allExp = spliced.sub + unspliced.sub #use combined spliced and unspliced counts 
#all.cpm = MUDAN::normalizeCounts(allExp) #cpm normalize
all.norm = MUDAN::normalizeVariance(allExp,details = TRUE, plot = FALSE) #variance stabilize 
odsGenes = rownames(allExp)[all.norm$ods] #overdispersed genes
all.logODS = as.matrix(t(all.norm$mat[all.norm$ods,])) #keep overdispersed genes 
```
```{r fig.width=5, fig.show = 'hide'}
#look at distribution of gene expression
mna = rowMeans(allExp)
sda = sapply(c(1:nrow(allExp)), function(x) sd(allExp[x,]))
#mnc = rowMeans(all.cpm)
#sdc = sapply(c(1:nrow(all.cpm)), function(x) sd(all.cpm[x,]))
mnv = rowMeans(all.norm$mat)
sdv = sapply(c(1:nrow(all.norm$mat)), function(x) sd(all.norm$mat[x,]))
mno = colMeans(all.logODS)
sdo = sapply(c(1:ncol(all.logODS)), function(x) sd(all.logODS[,x]))

par(mfrow = c(2,3))
hist(log10(mna+1), breaks = 500, main = "log10(mean gene exp)")
#hist(log10(mnc+1), breaks = 500, main = "log10(mean gene normalized)")
hist(mnv, breaks = 500, main = "mean gene exp variance stabilized")
hist(mno, breaks = 500, main = "mean gene exp overdispersed")
plot(log10(mna+1),log10(sda+1), main = "log10(Std Dev) vs \nlog10(mean gene exp)")
#plot(log10(mnc+1),log10(sdc+1), main = "log10(Std Dev) vs \nlog10(mean gene normalized)")
plot(mnv,sdv, main = "Std Dev vs \nmean gene exp variance stabilized")
plot(mno,sdo, main = "Std Dev vs mean \ngene exp overdispersed")

#all.logODS ~normal, no mean-variance dependence --> pca 
```



Dimensional reduction  
```{r dimensional reduction, included = FALSE, fig.show = 'hide'}
pca = svds(A = all.logODS, k=50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var = pca$d
plot(var) # ~10 components 

emb.pca = pca$u[,1:2]
row.names(emb.pca) = row.names(all.logODS)
plot(emb.pca, col = cell.cols, pch = 16, xlab = "PC1", ylab = "PC2", main = "PCA")


#pairwise cell dists for velocity calculation 
cell.dist = as.dist(1-cor(t(pca$u)))
```


Run velocyto on panc data  
```{r velocity, message = FALSE, results = 'hide', included = FALSE}
#vel = gene.relative.velocity.estimates(spliced.sub,unspliced.sub,deltaT=1,kCells=30,cell.dist=cell.dist,fit.quantile=0.1,mult=100)
#saveRDS(vel,file = "panc_vel_cellrank.rds")
vel = readRDS("/Users/lylaatta/OneDrive - Johns Hopkins/Johns Hopkins/ComputerTransfer/veloviz_largefiles/saved_objects/panc_vel_cellrank.rds")
curr = vel$current
proj = vel$projected

#show velocity on PCA
# show.velocity.on.embedding.cor(scale(emb.pca), vel, n=100, scale='sqrt', cell.colors=cell.cols.sub,cex=1, arrow.scale=1, show.grid.flow=TRUE,min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2, main = "Velocities on PCA embedding")

# #show velocity on UMAP 
# emb.umap.sub = emb_umap[rownames(emb.pca),]
# show.velocity.on.embedding.cor(scale(emb.umap.sub), vel, n=100, scale='sqrt', cell.colors=cell.cols.sub,cex=1, arrow.scale=1, show.grid.flow=TRUE,min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2, main = "Velocities on UMAP embedding")

```  

```{r, fig.show = 'hide'}
#look at gene exp distribution in curr and proj

par(mfrow = c(2,2))
currmeans = log10(rowMeans(curr)+1)
currsds = log10(sapply(c(1:nrow(curr)), function(x) sd(curr[x,]))+1)
hist(currmeans,breaks = 500, main = "curr: log mean gene exp")
plot(currmeans,currsds, main = "curr: log means vs log sds")

projmeans = log10(rowMeans(proj)+1)
projsds = log10(sapply(c(1:nrow(proj)), function(x) sd(proj[x,]))+1)
hist(projmeans,breaks = 500, main = "proj: log mean gene exp")
plot(projmeans,projsds, main = "proj: log means vs log sds")

curr.norm = MUDAN::normalizeVariance(curr,details = FALSE, plot = FALSE) #variance stabilize 
proj.norm = MUDAN::normalizeVariance(proj,details = FALSE, plot = FALSE) #variance stabilize 

par(mfrow = c(2,2))
curr.norm.means = log10(rowMeans(curr.norm)+1)
curr.norm.sds = log10(sapply(c(1:nrow(curr.norm)), function(x) sd(curr.norm[x,]))+1)
hist(curr.norm.means, breaks = 500)
plot(curr.norm.means, curr.norm.sds)

proj.norm.means = log10(rowMeans(proj.norm)+1)
proj.norm.sds = log10(sapply(c(1:nrow(proj.norm)), function(x) sd(proj.norm[x,]))+1)
hist(proj.norm.means, breaks = 500)
plot(proj.norm.means, proj.norm.sds)

#curr.norm and proj.norm ~normal and no mean-variance dependence --> pca 

```

```{r}
pca.velo = svds(A = t(curr.norm), k=50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var = pca.velo$d
#plot(var) # ~10 components 

emb.pca.velo = pca.velo$u[,1:2]
row.names(emb.pca.velo) = colnames(curr.norm)
plot(emb.pca.velo, col = cell.cols, pch = 16, xlab = "PC1", ylab = "PC2", main = "PCA")


```


Scores of observed and projected states in PC space  
```{r pc scores, included = FALSE,  fig.width = 7}
u = pca.velo$u #scores
v = pca.velo$v #loads
row.names(v) = rownames(curr.norm)

common.genes = sapply(row.names(curr.norm), function(x) x %in% odsGenes)
common.genes.names = rownames(curr.norm)[common.genes]
curr.pca = curr.norm[common.genes,]
v.sub = v[row.names(curr.pca),]

par(mfrow = c(1,2))
curr.scores = scale(t(curr.pca)) %*% v.sub
plot(curr.scores[,1:2], col = cell.cols, main = 'Observed')#,xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))

proj.pca = proj.norm[common.genes,]
proj.scores = scale(t(proj.pca)) %*% v.sub
plot(proj.scores[,1:2], col = cell.cols, main = 'Projected')#,xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))

```

Graph visualization on subset of cells from PC coordinates  
```{r graph viz from PCs, results = "hide", fig.height=8, fig.width = 8}
source("projectedNeighbors_weightedCD.R")
ws = c(0.1,1,10,25,50,100)
par(mfrow = c(3,2))
for (w in ws){
  set.seed(1)
  vizg = graphViz(t(curr.scores), t(proj.scores), k=30, distance_metric = "L2", similarity_metric = "cosine", distance_weight = w, similarity_threshold = 0, weighted = TRUE, cell.colors = cell.cols,plot = TRUE, return_graph = TRUE,title = paste("Weight = ", w))
}






```

```{r}
w = 1
set.seed(1)
vizg = graphViz(t(curr.scores), t(proj.scores), k=30, distance_metric = "L2", similarity_metric = "cosine", distance_weight = w, similarity_threshold = 0, weighted = TRUE, cell.colors = cell.cols,plot = TRUE, return_graph = TRUE,title = paste("Weight = ", w))


```


#### Comparing graphs from each method 
```{r compare consistiency scores, eval = FALSE}
#picking default weight for cellrank graph w = 0.8 
#picking default settings for composite distance, w=1, thresh=0
#k = 30 for both

tm_combined = (0.8*vtm) + ((1-0.8)*ctm) #weighted average of velocity and connectivity transition matrices
cr_graph = graph_from_adjacency_matrix(tm_combined, mode = "directed", weighted = TRUE)
set.seed(1)
cr_fdg = layout_with_fr(cr_graph, dim = 2)
plot(cr_fdg, pch = 16, col = cell.cols, main = paste(paste("k = 30, weight = 0.8")))

set.seed(1)
viz_graph = graphViz(t(curr.scores), t(proj.scores), k=30, distance_metric = "L2", similarity_metric = "cosine", distance_weight = 1, similarity_threshold = 0, weighted = TRUE, cell.colors = cell.cols,plot = FALSE, return_graph = TRUE,title = paste("k = 30, weight = 1, t=0"))
viz_fdg = viz_graph$fdg_coords
plot(viz_fdg, pch = 16, col = cell.cols, main = paste(paste("k = 30, weight = 1, t=0")))

#extract velocities from each model 
cr_vel = as.matrix(adata$layers['velocity'])
rownames(cr_vel) = as.character(adata$obs_names$values)
colnames(cr_vel) = as.character(adata$var_names$values)
cr_vel = t(cr_vel)
cr_vel[is.nan(cr_vel)] = 0
viz_vel = vel$deltaE

#calculate consistency scores for each model 
cr_consistency = consistency(cr_fdg, cr_vel, 30, TRUE)
viz_consistency = consistency(viz_fdg, viz_vel, 30, TRUE)






neighbor.cors = pwiseCors(as.matrix(viz_vel),viz_consistency,30)


source("projectedNeighbors_weightedCD.R")


```

```{r compare clustering coefficient, eval = FALSE}

```












