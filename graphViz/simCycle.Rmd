---
title: "Cycle Simulation"
author: "LylaAtta"
date: "10/22/2020"
output: html_document
---

adapted from Jean's simulation  
looking at "unwrapping" of cycle in velocity based embedding and effect of changing distance weights  

```{r setup, include=FALSE}
#using velo_splatter evironment 
knitr::opts_chunk$set(echo = FALSE)
library(Rcpp)
#library(reticulate)
library(igraph)
library(matie)
library(RANN)
library(velocyto.R)
library(MUDAN)
library(RSpectra)
library(umap)
library(Rtsne)
library(destiny)
library(splatter)
library(scater)
#library(dyngen)
#library(dyntoy)
source("projectedNeighbors.R")
```


```{r jeantest1}
## make circle like cell cycle
par(mfrow=c(1,1))
x <- matrix(rnorm(1000),nc=2)
y <- x/sqrt(rowSums(x^2))
## add some jitter
obs <- t(y)
obs <- jitter(obs, amount = 0.25)
## order points counterclockwise
angle <- atan2(obs[2,], obs[1,])
#angle

obs <- obs[, order(angle)]
#obs
## rainbow
col = colorRampPalette(c(rainbow(10)))(ncol(obs))
labels <- paste0('cell', 1:ncol(obs))
## plot
plot(t(obs),col=col, pch=16)
text(t(obs[,seq(175,225,5)]), labels[seq(175,225,5)])

colnames(obs) <- labels
```

Remove some transient cells

```{r jeantestremove}
cells.keep <- setdiff(labels, paste0('cell', 200:300))
# cells.keep

labels <- labels[which(labels %in% cells.keep)]
obs <- obs[,cells.keep]
plot(t(obs),col=col, pch=16)
text(t(obs[,seq(150,199,by=5)]), labels[seq(150,199,by=5)])
text(t(obs[,seq(200,250,by=7)]), as.character(seq(200,250,by=7))) #labels[seq(200,250,by=7)]

```

Simulate lower dimensional representation of future transcriptional state

```{r jeantest2}
## rotate circle slightly
f = pi*0.1 # adjust as needed
exp = t(obs)
exp[,1] = obs[1,]*cos(f) - obs[2,]*sin(f)
exp[,2] = obs[2,]*cos(f) + obs[1,]*sin(f)
exp = t(exp)

plot(t(obs),col=col, pch=16)
points(t(exp),col=col)
arrows(t(obs)[,1],t(obs)[,2],t(exp)[,1],t(exp)[,2])

colnames(exp) <- labels
```

Try different embeddings

```{r jeantest_veloviz, fig.width=7,fig.height=7}
k = 10
## Lyla's FDG
set.seed(1)
gsim = graphViz(obs, exp, k, cell.colors=col, similarity_threshold = -1, weighted=TRUE, plot = TRUE, return_graph = TRUE)
#plot(gsim$fdg_coords, main = "FDG: vertex coordinates", col=col, pch=16)
#text(gsim$fdg_coords+0.1, labels = labels)

```


#Behavior of weights with noise 
```{r, fig.width=10, fig.height=10}
js = c(0.1, 0.25, 0.5, 1) #jitter amounts 
as = c(0.01, 0.05, 0.1, 0.5) #angles to rotate for exp

j01 = list()
ks = c(5,10,50,100)

par(mfrow=c(4,3))
for (j in js){
  ## make circle like cell cycle
  x <- matrix(rnorm(1000),nc=2)
  y <- x/sqrt(rowSums(x^2))
  ## add some jitter
  obs <- t(y)
  obs <- jitter(obs, amount = j)
  ## order points counterclockwise
  angle <- atan2(obs[2,], obs[1,])
  
  obs <- obs[, order(angle)]
  ## rainbow
  col = colorRampPalette(c(rainbow(10)))(ncol(obs))
  labels <- paste0('cell', 1:ncol(obs))
  ## plot
  #plot(t(obs),col=col, pch=16)
  #text(t(obs), labels)
  
  colnames(obs) <- labels
  
  #remove some cells 
  cells.keep <- setdiff(labels, paste0('cell', 200:300))

  labels <- labels[cells.keep]
  obs <- obs[,cells.keep]
  #plot(t(obs),col=col, pch=16)
  
  ## rotate circle slightly
  for (a in as[3]){
    f = pi*a # adjust as needed
    exp = t(obs)
    exp[,1] = obs[1,]*cos(f) - obs[2,]*sin(f)
    exp[,2] = obs[2,]*cos(f) + obs[1,]*sin(f)
    exp = t(exp)
    
    plot(t(obs),col=col, pch=16)
    points(t(exp),col=col)
    arrows(t(obs)[,1],t(obs)[,2],t(exp)[,1],t(exp)[,2])
    
    colnames(exp) <- labels
    #par(mfrow=c(2,4))
    for(k in ks[3]){
      set.seed(1)
      gsim = graphViz(obs, exp, k, cell.colors=col, similarity_threshold = -1, weighted=TRUE, plot = FALSE, return_graph = TRUE)
      j01[[as.character(j)]] = gsim
      plot(gsim$fdg_coords, main = paste0("FDG: vertex coordinates\nJitter:",j,"Angle:",a,"*pi, K:",k), col=col, pch=16)
      
      g <- gsim$graph
      V(g)$label = NA
      V(g)$size = 2
      E(g)$arrow.size = 0.5
      E(g)$color = rgb(0,0,0,0.1)
      plot(g)
    }
    
  }
  
}


```


```{r, fig.width = 7, fig.height=7}

par(mfrow = c(4,2))
for (k in c(1:4)){
  gn = j01[[k]]
  #plot(gn$graph)
  end.edges = E(gn$graph)[.from(c(150:199))]
  end.edges.idx = which(E(gn$graph) %in% end.edges)
  end.edges.wts = E(gn$graph)$weight[end.edges.idx]
  #par(mfrow = c(2,1))
  hist(log10(E(gn$graph)$weight), breaks = 500, main = paste0("All edge weights, jitter:",js[k]), xlim = c(-3,3))
  hist(log10(end.edges.wts), breaks = 100, main = paste0("End edge weights, jitter:",js[k]), xlim = c(-3,3))
  }
```


```{r}
par(mfrow = c(2,2))
for (k in c(1:4)){
  gn = j01[[k]]
  #plot(gn$graph)
  adj.nodes = unlist(adjacent_vertices(gn$graph,c(150:199),mode = "out"))
  hist(adj.nodes, breaks = 500, main = paste0("Adjacent nodes to end nodes, jitter:",js[k]), xlab = "Cell Index", xlim = c(150,350), ylim = c(0,50))
  }


```


```{r fig.width = 7, fig.height=7}
par(mfrow = c(4,3))
for (k in c(1:4)){
  gn = j01[[k]]
  
  knn = gn$projected_neighbors$kNNs
  inv.euc = gn$projected_neighbors$dist_comp$invDist
  neg.sim = gn$projected_neighbors$dist_comp$negVectSim
  all.dists = gn$projected_neighbors$all_dists
  all.dists = max(all.dists,na.rm = TRUE) - all.dists
  
  hist(log10(inv.euc), breaks = 500, main = paste0("All inverse euclidean, jitter:",js[k]), xlim = c(-0.5,3), ylim = c(0,4000))
  hist(neg.sim, breaks = 500, main = paste0("All negative similarity, jitter:",js[k]), xlim = c(-1,1), ylim = c(0,5500))
  hist(log10(all.dists), breaks = 500, main = paste0("All composite dists, jitter:",js[k]))#, xlim = c(-0.5,3), ylim = c(0,4000))
  
  }

par(mfrow = c(4,2))
for (k in c(1:4)){
  gn = j01[[k]]
  
  knn = gn$projected_neighbors$kNNs
  inv.euc = gn$projected_neighbors$dist_comp$invDist
  neg.sim = gn$projected_neighbors$dist_comp$negVectSim
  inv.euc.keep = t(sapply(c(1:399), function(x) inv.euc[x,knn[x,]]))
  neg.sim.keep = t(sapply(c(1:399), function(x) neg.sim[x,knn[x,]]))
  
  hist(log10(inv.euc.keep), breaks = 500, main = paste0("Inverse euclidean, jitter:",js[k]), xlim = c(-0.5,3), ylim = c(0,200))
  hist(neg.sim.keep, breaks = 500, main = paste0("Negative similarity, jitter:",js[k]), xlim = c(-1,-0.1), ylim = c(0,3500))
  }


```


#Behavior of weights with k 
```{r, fig.width=10, fig.height=10}
js = c(0.1, 0.25, 0.5, 1) #jitter amounts 
as = c(0.01, 0.05, 0.1, 0.5) #angles to rotate for exp

j01 = list()
ks = c(5,10,50,100)

#par(mfrow=c(4,3))
for (j in js[2]){
  ## make circle like cell cycle
  x <- matrix(rnorm(1000),nc=2)
  y <- x/sqrt(rowSums(x^2))
  ## add some jitter
  obs <- t(y)
  obs <- jitter(obs, amount = j)
  ## order points counterclockwise
  angle <- atan2(obs[2,], obs[1,])
  
  obs <- obs[, order(angle)]
  ## rainbow
  col = colorRampPalette(c(rainbow(10)))(ncol(obs))
  labels <- paste0('cell', 1:ncol(obs))
  ## plot
  #plot(t(obs),col=col, pch=16)
  #text(t(obs), labels)
  
  colnames(obs) <- labels
  
  #remove some cells 
  cells.keep <- setdiff(labels, paste0('cell', 200:300))

  labels <- labels[cells.keep]
  obs <- obs[,cells.keep]
  #plot(t(obs),col=col, pch=16)
  
  ## rotate circle slightly
  for (a in as[3]){
    f = pi*a # adjust as needed
    exp = t(obs)
    exp[,1] = obs[1,]*cos(f) - obs[2,]*sin(f)
    exp[,2] = obs[2,]*cos(f) + obs[1,]*sin(f)
    exp = t(exp)
    
    # plot(t(obs),col=col, pch=16)
    # points(t(exp),col=col)
    # arrows(t(obs)[,1],t(obs)[,2],t(exp)[,1],t(exp)[,2])
    
    colnames(exp) <- labels
    par(mfrow=c(2,4))
    for(k in ks){
      set.seed(1)
      gsim = graphViz(obs, exp, k, cell.colors=col, similarity_threshold = -1, weighted=TRUE, plot = FALSE, return_graph = TRUE)
      j01[[as.character(j)]] = gsim
      plot(gsim$fdg_coords, main = paste0("FDG: vertex coordinates\nJitter:",j,"Angle:",a,"*pi, K:",k), col=col, pch=16)
      
      g <- gsim$graph
      V(g)$label = NA
      V(g)$size = 2
      E(g)$arrow.size = 0.5
      E(g)$color = rgb(0,0,0,0.1)
      plot(g)
    }
    
  }
  
}


```















