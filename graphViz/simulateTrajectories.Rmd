---
title: "Simulate Trajectories"
author: "LylaAtta"
date: "9/24/2020"
output: html_document
---

Here, I want to simulate scRNA-seq data from trajctories to benchmark performance of velocity based visualization.   

#### Setup and get data from scVelo
```{r setup, include=FALSE}
#using velo_splatter evironment 
knitr::opts_chunk$set(echo = FALSE)
library(reticulate)
library(igraph)
library(matie)
library(RANN)
library(velocyto.R)
library(MUDAN)
library(RSpectra)
library(umap)
library(splatter)
library(scater)
library(dyngen)
library(dyntoy)
source("projectedNeighbors.R")
```

#### Dynverse demo
```{r}
set.seed(10)
model = initialise_model(
  num_tfs = 12,
  num_targets = 30,
  num_hks = 15,
  backbone = backbone_trifurcating(),
  verbose = TRUE,
  download_cache_dir = "~/.cache/dyngen",
  num_cores = 8, 
  experiment_params = params
)

```

```{r}
#plot_backbone_statenet(model)
#plot_backbone_modulenet(model)
model = generate_tf_network(model)
#plot_feature_network(model, show_targets = FALSE)
model = generate_kinetics(model)
#plot_feature_network(model, show_hks = TRUE)
model = generate_gold_standard(model)
#plot_gold_simulations(model)
model = generate_cells(model) 
#plot_simulations(model)
model = generate_experiment(model)

```

```{r}
plot_backbone_statenet(model)
plot_backbone_modulenet(model)
plot_feature_network(model, show_targets = FALSE)
plot_feature_network(model, show_hks = TRUE)
plot_gold_simulations(model)
plot_simulations(model)

```

```{r}
c = model$simulations$counts
```


```{r}
data = generate_dataset(model = "bifurcating",num_cells = 1000, num_features = 2000) 
counts = data$counts
exp_now = data$expression
exp_proj = data$expression_projected
```


```{r}
pca = svds(A = exp_now, k=50, opts = list(center = TRUE, scale = TRUE, maxitr = 2000, tol = 1e-10))
var = pca$d
plot(var) # ~4 components 
v = pca$v

now.scores = exp_now %*% v
proj.scores = exp_proj %*% v

plot(pca$u[,1:2],pch=4)

now.emb = scale(now.scores[,1:2])
proj.emb = scale(proj.scores[,1:2])

plot(now.emb, pch = 4, xlab = "PC1", ylab = "PC2", main = "PCA on simulated data", xlim = c(-2,2.5), ylim = c(-1.5,2.5))
points(proj.emb,col = "blue",pch = 4)
points(now.emb[1:5,], pch = 16, col = "red")
text(now.emb[1:5,]-0.1,label = c(1:5), col = "red")
points(proj.emb[1:5,],col = "green",pch = 16)
text(proj.emb[1:5,]-0.1,label = c(1:5), col = "green")
legend(x = 1.5, y = 0, c("exp","exp_proj","exp","exp_proj"), col = c("black", "blue","red","green"), pch = c(4,4,16,16))


```

```{r}
#downsample
now.scores.sub = scale(now.scores[seq(1,1000,by=3),])
proj.scores.sub = scale(proj.scores[seq(1,1000,by=3),])

plot(now.scores.sub[,1:2], pch = 4, xlab = "PC1", ylab = "PC2", main = "PCA on simulated data",xlim = c(-2,2.5), ylim = c(-1.5,2.5))
points(proj.scores.sub[,1:2],col = "blue",pch = 4)
points(now.scores.sub[1:5,], pch = 16, col = "red")
text(now.scores.sub[1:5,]-0.1,label = c(1:5), col = "red")
points(proj.scores.sub[1:5,],col = "green",pch = 16)
text(proj.scores.sub[1:5,]-0.1,label = c(1:5), col = "green")
legend(x = 1.5, y = 0, c("exp","exp_proj","exp","exp_proj"), col = c("black", "blue","red","green"), pch = c(4,4,16,16))

g = graphViz(observed = t(now.scores.sub[,1:4]), projected = t(proj.scores.sub[,1:4]), 
             k = 10, distance_metric = "L2", similarity_metric = "cosine", similarity_threshold = -1, weighted = TRUE, 
             cell.colors = NA, title = NA, plot = FALSE, return_graph = TRUE)
  
plot(g$graph)
plot(g$fdg_coords)
```

```{r}
multi1 = readRDS('./saved_objects/simulated_trajectories/looping_1.rds')
multi1_exp = multi1$expression

pca = svds(A = multi1_exp, k=50, opts = list(center = TRUE, scale = TRUE, maxitr = 2000, tol = 1e-10))
var = pca$d
plot(var) # ~6 components 
v = pca$v

now.scores = exp_now %*% v
proj.scores = exp_proj %*% v

plot(scale(pca$u[,1:2]),pch=4)

now.emb = scale(now.scores[,1:2])
proj.emb = scale(proj.scores[,1:2])

plot(now.emb, pch = 4, xlab = "PC1", ylab = "PC2", main = "PCA on simulated data", xlim = c(-2,2.5), ylim = c(-1.5,2.5))
points(proj.emb,col = "blue",pch = 4)
points(now.emb[1:5,], pch = 16, col = "red")
text(now.emb[1:5,]-0.1,label = c(1:5), col = "red")
points(proj.emb[1:5,],col = "green",pch = 16)
text(proj.emb[1:5,]-0.1,label = c(1:5), col = "green")
legend(x = 1.5, y = 0, c("exp","exp_proj","exp","exp_proj"), col = c("black", "blue","red","green"), pch = c(4,4,16,16))


```





#### Splatter demo 
```{r splatter demo}
#example counts 
#mock counts 
set.seed(1)
demoData = mockSCE()
demoCounts = demoData@assays@data$counts
hist(colSums(demoCounts), breaks = 500)

#estimate simulation parameters
params = splatEstimate(demoCounts)
params = setParam(params, "dropout.type", "experiment")

#simulate single static group 
sim = splatSimulate(params, nGenes = 1000, batchCells = 500)
simCounts = counts(sim)
sim = logNormCounts(sim)
sim = runPCA(sim)
plotPCA(sim)

#simulate multiple groups
sim.groups = splatSimulate(params, nGenes = 1000, batchCells = 500, group.prob = c(0.5,0.5), de.prob = 0.2, method = "groups")
sim.groups = logNormCounts(sim.groups)
sim.groups = runPCA(sim.groups)
plotPCA(sim.groups, colour_by = "Group")

#simulating paths
sim.paths = splatSimulate(params, nGenes = 1000, batchCells = 500, de.prob = 0.7, method = "paths")
sim.paths = logNormCounts(sim.paths)
sim.paths = runPCA(sim.paths)
plotPCA(sim.paths, colour_by = "Step")

#simulating bifurcation 
sim.bi = mfaSimulate()

```

Use the reticulate package to use scVelo from within R:   
```{r importing scvelo}
use_condaenv("velo",required = TRUE)
scv = import("scvelo")
#scv$logging$print_version()
```

```{r loading panc data, message=FALSE}
adata = scv$datasets$pancreas()
#scv$pl$scatter(adata,legend_loc = "lower left", size = 60)


emb_umap = adata$obsm['X_umap'] #extract umap embedding 
clusters = adata$obs$clusters #extract clusters 
rownames(emb_umap) = names(clusters) = adata$obs_names$values

col = rainbow(length(levels(clusters)),s = 0.8, v = 0.8) 
cell.cols = col[clusters] #color according to cluster
names(cell.cols) = names(clusters)
```

```{r plot panc data on umap}
plot(emb_umap, col = cell.cols, pch=16, xlab = "UMAP X", ylab = "UMAP Y", xlim = c(-15,20))
legend(x=10, y=6, legend = levels(clusters), col = col, pch = 16)
```

#### Compute velocities on pancreas data using velocyto
Extract spliced and unspliced data  
```{r extract counts, message = FALSE, results='hide'}
spliced = as.matrix(t(adata$layers['spliced']))
unspliced = as.matrix(t(adata$layers['unspliced']))
cells = adata$obs_names$values
genes = adata$var_names$values
colnames(spliced) = colnames(unspliced) = cells
rownames(spliced) = rownames(unspliced) = genes
```

Extract PCA coordinates  
```{r scvelo pca, message = FALSE, results='hide'}
pcs = adata$obsm['X_pca']
rownames(pcs) = cells
cell.dist = as.dist(1-cor(t(pcs))) #cell distance in PC space --- I should probably use the dist calculated from PCA below 
```

Filter genes  
```{r filter genes, message = FALSE }
gexpS = log10(rowSums(spliced)+1)
gexpU = log10(rowSums(unspliced)+1)
#plot(gexpS,gexpU)
goodGenes = genes[gexpS > 2 & gexpU > 1]
spliced = spliced[goodGenes,]
unspliced = unspliced[goodGenes,]
```

Downsample cells to make things easier  
```{r downsample, results='hide'}
spliced.sub = spliced[,seq(1,ncol(spliced),by=3)]
cell.names.sub = colnames(spliced.sub)
unspliced.sub = unspliced[,seq(1,ncol(unspliced),by=3)]
cell.dist.sub = as.dist(1-cor(t(pcs[seq(1,ncol(unspliced),by=3),])))
cell.cols.sub = cell.cols[colnames(spliced.sub)]
```

Normalize for dimensional reduction  
```{r normalize, results='hide'}
allExp = spliced.sub + unspliced.sub #use combined spliced and unspliced counts 
all.cpm = MUDAN::normalizeCounts(allExp) #cpm normalize
all.norm = MUDAN::normalizeVariance(all.cpm,details = TRUE, plot = FALSE) #variance stabilize 
odsGenes = goodGenes[all.norm$ods] #overdispersed genes
all.logODS = log10(as.matrix(t(all.norm$mat[all.norm$ods,]))+1) #keep overdispersed genes and log normalize
```

Dimensional reduction  
```{r dimensional reduction}
pca = svds(A = all.logODS, k=50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var = pca$d
#plot(var) # ~5 components 

emb.pca = pca$u[,1:2]
row.names(emb.pca) = row.names(all.logODS)
plot(emb.pca, col = cell.cols.sub, pch = 16, xlab = "PC1", ylab = "PC2", main = "PCA on subsampled data", xlim = c(-0.04,0.07))
legend(x=0.04, y=0, legend = levels(clusters), col = col, pch = 16)

```

```{r umap, fig.height=5, fig.width=7}
pcsToKeep = pca$u[,1:20]
set.seed(1)
emb.umap = umap(pcsToKeep)$layout
row.names(emb.umap) = row.names(all.logODS)
plot(scale(emb.umap),col = cell.cols.sub, pch = 16, xlab = "UMAP X", ylab = "UMAP Y",main = "UMAP on subsampled data", xlim = c(-2,3))
legend(x=1.75, y=0.75, legend = levels(clusters), col = col, pch = 16)
```



Run velocyto on panc data  
```{r velocity, message = FALSE, results = 'hide'}
#vel = gene.relative.velocity.estimates(spliced.sub,unspliced.sub,deltaT=1,kCells=30,cell.dist=cell.dist.sub,fit.quantile=0.1,mult=100)
#saveRDS(vel,file = "panc_vel.rds")
vel = readRDS("./saved_objects/panc_vel.rds")
curr = vel$current
proj = vel$projected

#show velocity on PCA
show.velocity.on.embedding.cor(scale(emb.pca), vel, n=100, scale='sqrt', cell.colors=cell.cols.sub,cex=1, arrow.scale=1, show.grid.flow=TRUE,min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2, main = "Velocities on PCA embedding")
legend(x=1, y=-1, legend = levels(clusters), col = col, pch = 16)

#show velocity on UMAP 
emb.umap.sub = emb_umap[rownames(emb.pca),]
show.velocity.on.embedding.cor(scale(emb.umap.sub), vel, n=100, scale='sqrt', cell.colors=cell.cols.sub,cex=1, arrow.scale=1, show.grid.flow=TRUE,min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2, main = "Velocities on UMAP embedding")
legend(x=-0.5, y=2, legend = levels(clusters), col = col, pch = 16)

```

#### Graph visualization 

Scores of observed and projected states in PC space  
```{r pc scores}
u = pca$u #scores
v = pca$v #loads
row.names(v) = odsGenes

common.genes = sapply(row.names(curr), function(x) x %in% odsGenes)
common.genes.names = rownames(curr)[common.genes]
curr.pca = curr[common.genes,]
v.sub = v[row.names(curr.pca),]

par(mfrow = c(1,2))

curr.scores = t(curr.pca) %*% v.sub
plot(curr.scores[,1:2], col = cell.cols.sub, main = 'Observed',xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))

proj.pca = proj[common.genes,]
proj.scores = t(proj.pca) %*% v.sub
plot(proj.scores[,1:2], col = cell.cols.sub, main = 'Projected',xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))

```

Graph visualization on subset of cells from PC coordinates  
```{r graph viz from PCs, results = "hide"}
cell.names = colnames(curr)
cell.names.sub = cell.names[seq(1,length(cell.names),3)] #downsample cells for speed 
ncells.sub = length(cell.names.sub)
cell.cols.grph = cell.cols[cell.names.sub]

curr.scores.cellsub = t(curr.scores[cell.names.sub,]) #### change here to change number of PCs included 
proj.scores.cellsub = t(proj.scores[cell.names.sub,]) ####

set.seed(1)
graphViz(observed = curr.scores.cellsub, projected = proj.scores.cellsub,
         k = 10, distance_metric = "L2", similarity_metric = "cosine", similarity_threshold = 0.25, weighted = TRUE,
         cell.colors = cell.cols.grph, title = "K = 10",
         plot = TRUE, return_graph = FALSE)
legend(x=-1.75, y=0, legend = levels(clusters), col = col, pch = 16)

```

#### Removing intermediate cell types
First, we'll see if removing Ngn3 low EP cell types affects the visualization. Given that there are only relatively few of these cells, I suspect that the effect won't be noticeable in the visualization.  
```{r removing Ngn3 low EP, eval = FALSE}
not.epLow.bars = names(clusters)[which(clusters != "Ngn3 low EP")]
currSub.names = cell.names.sub[cell.names.sub %in% not.epLow.bars] 
currSub.n = length(currSub.names)
currSub.cols = cell.cols[currSub.names]

currSub.currScores = t(curr.scores[currSub.names,])
currSub.projScores = t(proj.scores[currSub.names,])

set.seed(1)
graphViz(observed = currSub.currScores, projected = currSub.projScores,
         k = 10, distance_metric = "L2", similarity_metric = "cosine", similarity_threshold = 0.25, weighted = TRUE,
         cell.colors = currSub.cols, title = "K = 10",
         plot = TRUE, return_graph = FALSE)
legend(x=-2.75, y=-0.1, legend = levels(clusters), col = col, pch = 16)

```  

As expected, the visualization doesn't change very much by removing Ngn3 low EP cells. Next, let's see the effect of removing Ngn3 high EP or Pre-endocrine cells.  
First, remove pre-endocrine cells..  
```{r removing pre-endocrine cells}
not.preend.bars = names(clusters)[which(clusters != "Pre-endocrine")]
pca.names.sub = cell.names[cell.names %in% not.preend.bars]
all.logODS.sub = all.logODS[pca.names.sub,]
pca.cols.sub = cell.cols[pca.names.sub]

## run pca without current cell type 
pca.sub = svds(A = all.logODS.sub, k=50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var.sub = pca.sub$d
#plot(var.sub) # ~4 components 

emb.pca.sub = pca.sub$u[,1:2]
row.names(emb.pca.sub) = row.names(all.logODS.sub)
plot(emb.pca.sub, col = pca.cols.sub, pch = 16, xlab = "PC1", ylab = "PC2", main = "PCA on subsampled data \nw/o preendocrine cells", xlim = c(-0.04,0.07))
legend(x=0.04, y=0.08, legend = levels(clusters), col = col, pch = 16)

## scores of current and projected 
u.currTypes = pca.sub$u #scores
v.currTypes = pca.sub$v #loads
row.names(v.currTypes) = odsGenes

common.genes = sapply(row.names(curr), function(x) x %in% odsGenes)
common.genes.names = rownames(curr)[common.genes]
curr.pca = curr[common.genes,pca.names.sub]
v.sub = v.currTypes[row.names(curr.pca),]

par(mfrow = c(1,2))

curr.scores = t(curr.pca) %*% v.sub
plot(curr.scores[,1:2], col = pca.cols.sub, main = 'Observed',xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))

proj.pca = proj[common.genes,pca.names.sub]
proj.scores = t(proj.pca) %*% v.sub
plot(proj.scores[,1:2], col = pca.cols.sub, main = 'Projected',xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))

## make graph using new current and projected scores 
currSub.names = cell.names.sub[cell.names.sub %in% not.preend.bars]
currSub.n = length(currSub.names)
currSub.cols = cell.cols[currSub.names]

currSub.currScores = t(curr.scores[currSub.names,])
currSub.projScores = t(proj.scores[currSub.names,])

set.seed(1)
graphViz(observed = currSub.currScores, projected = currSub.projScores,
         k = 10, distance_metric = "L2", similarity_metric = "cosine", similarity_threshold = 0.25, weighted = TRUE,
         cell.colors = currSub.cols, title = "K = 10",
         plot = TRUE, return_graph = FALSE)
legend(x=1.5, y=1.5, legend = levels(clusters), col = col, pch = 16)

```

...and now Ngn3 high EP  
```{r removing ngn3 high EP cells}
not.epHigh.bars = names(clusters)[which(clusters != "Ngn3 high EP")]
pca.names.sub = cell.names[cell.names %in% not.epHigh.bars]
all.logODS.sub = all.logODS[pca.names.sub,]
pca.cols.sub = cell.cols[pca.names.sub]

## run pca without current cell type 
pca.sub = svds(A = all.logODS.sub, k=50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var.sub = pca.sub$d
#plot(var.sub) # ~4 components 

emb.pca.sub = pca.sub$u[,1:2]
row.names(emb.pca.sub) = row.names(all.logODS.sub)
plot(emb.pca.sub, col = pca.cols.sub, pch = 16, xlab = "PC1", ylab = "PC2", main = "PCA on subsampled data \nw/o EP high cells", xlim = c(-0.04,0.07))
legend(x=0.04, y=0.08, legend = levels(clusters), col = col, pch = 16)

## scores of current and projected 
u.currTypes = pca.sub$u #scores
v.currTypes = pca.sub$v #loads
row.names(v.currTypes) = odsGenes

common.genes = sapply(row.names(curr), function(x) x %in% odsGenes)
common.genes.names = rownames(curr)[common.genes]
curr.pca = curr[common.genes,pca.names.sub]
v.sub = v.currTypes[row.names(curr.pca),]

par(mfrow = c(1,2))

curr.scores = t(curr.pca) %*% v.sub
plot(curr.scores[,1:2], col = pca.cols.sub, main = 'Observed',xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))

proj.pca = proj[common.genes,pca.names.sub]
proj.scores = t(proj.pca) %*% v.sub
plot(proj.scores[,1:2], col = pca.cols.sub, main = 'Projected',xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))

## make graph using new current and projected scores 
currSub.names = cell.names.sub[cell.names.sub %in% not.epHigh.bars]
currSub.n = length(currSub.names)
currSub.cols = cell.cols[currSub.names]

currSub.currScores = t(curr.scores[currSub.names,])
currSub.projScores = t(proj.scores[currSub.names,])

set.seed(1)
graphViz(observed = currSub.currScores, projected = currSub.projScores,
         k = 10, distance_metric = "L2", similarity_metric = "cosine", similarity_threshold = 0.25, weighted = TRUE,
         cell.colors = currSub.cols, title = "K = 10",
         plot = TRUE, return_graph = FALSE)
legend(x=1, y=-1, legend = levels(clusters), col = col, pch = 16)

```

Let's try removing multiple subsets, Ngn3 highEP and Pre-endocrine  
```{r removing ngn3 high EP and preendocrine cells}
not.epHighORpreend.bars = names(clusters)[which(clusters != "Ngn3 high EP"  & clusters != "Pre-endocrine")]
pca.names.sub = cell.names[cell.names %in% not.epHighORpreend.bars]
all.logODS.sub = all.logODS[pca.names.sub,]
pca.cols.sub = cell.cols[pca.names.sub]

## run pca without current cell type 
pca.sub = svds(A = all.logODS.sub, k=50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var.sub = pca.sub$d
#plot(var.sub) # ~4 components 

emb.pca.sub = pca.sub$u[,1:2]
row.names(emb.pca.sub) = row.names(all.logODS.sub)
plot(emb.pca.sub, col = pca.cols.sub, pch = 16, xlab = "PC1", ylab = "PC2", main = "PCA on subsampled data \nw/o EP high or preendocrine cells", xlim = c(-0.04,0.08))
legend(x=0.05, y=0.08, legend = levels(clusters), col = col, pch = 16)

## scores of current and projected 
u.currTypes = pca.sub$u #scores
v.currTypes = pca.sub$v #loads
row.names(v.currTypes) = odsGenes

common.genes = sapply(row.names(curr), function(x) x %in% odsGenes)
common.genes.names = rownames(curr)[common.genes]
curr.pca = curr[common.genes,pca.names.sub]
v.sub = v.currTypes[row.names(curr.pca),]

par(mfrow = c(1,2))

curr.scores = t(curr.pca) %*% v.sub
plot(curr.scores[,1:2], col = pca.cols.sub, main = 'Observed',xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))

proj.pca = proj[common.genes,pca.names.sub]
proj.scores = t(proj.pca) %*% v.sub
plot(proj.scores[,1:2], col = pca.cols.sub, main = 'Projected',xlim = c(-0.55,0.25),ylim = c(-0.35,0.45))

## make graph using new current and projected scores 
currSub.names = cell.names.sub[cell.names.sub %in% not.epHighORpreend.bars]
currSub.n = length(currSub.names)
currSub.cols = cell.cols[currSub.names]

currSub.currScores = t(curr.scores[currSub.names,])
currSub.projScores = t(proj.scores[currSub.names,])

set.seed(1)
graphViz(observed = currSub.currScores, projected = currSub.projScores,
         k = 10, distance_metric = "L2", similarity_metric = "cosine", similarity_threshold = 0.25, weighted = TRUE,
         cell.colors = currSub.cols, title = "K = 10",
         plot = TRUE, return_graph = FALSE)
legend(x=2, y=0, legend = levels(clusters), col = col, pch = 16)

```

#### Removing terminal cell types 
```{r removing beta cells}
not.beta.bars = names(clusters)[which(clusters != "Beta")]
pca.names.sub = cell.names[cell.names %in% not.beta.bars]
all.logODS.sub = all.logODS[pca.names.sub,]
pca.cols.sub = cell.cols[pca.names.sub]

## run pca without current cell type 
pca.sub = svds(A = all.logODS.sub, k=50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var.sub = pca.sub$d
#plot(var.sub) # ~4 components 

emb.pca.sub = pca.sub$u[,1:2]
row.names(emb.pca.sub) = row.names(all.logODS.sub)
plot(emb.pca.sub, col = pca.cols.sub, pch = 16, xlab = "PC1", ylab = "PC2", main = "PCA on subsampled data \nw/o alpha cells", xlim = c(-0.05,0.07))
legend(x=0.04, y=0.06, legend = levels(clusters), col = col, pch = 16)

## scores of current and projected 
u.currTypes = pca.sub$u #scores
v.currTypes = pca.sub$v #loads
row.names(v.currTypes) = odsGenes

common.genes = sapply(row.names(curr), function(x) x %in% odsGenes)
common.genes.names = rownames(curr)[common.genes]
curr.pca = curr[common.genes,pca.names.sub]
v.sub = v.currTypes[row.names(curr.pca),]

par(mfrow = c(1,2))

curr.scores = t(curr.pca) %*% v.sub
plot(curr.scores[,1:2], col = pca.cols.sub, main = 'Observed',xlim = c(-0.5,0.3),ylim = c(-0.4,0.5))

proj.pca = proj[common.genes,pca.names.sub]
proj.scores = t(proj.pca) %*% v.sub
plot(proj.scores[,1:2], col = pca.cols.sub, main = 'Projected',xlim = c(-0.5,0.3),ylim = c(-0.4,0.5))

## make graph using new current and projected scores 
currSub.names = cell.names.sub[cell.names.sub %in% not.beta.bars]
currSub.n = length(currSub.names)
currSub.cols = cell.cols[currSub.names]

currSub.currScores = t(curr.scores[currSub.names,])
currSub.projScores = t(proj.scores[currSub.names,])

set.seed(1)
graphViz(observed = currSub.currScores, projected = currSub.projScores,
         k = 10, distance_metric = "L2", similarity_metric = "cosine", similarity_threshold = 0.25, weighted = TRUE,
         cell.colors = currSub.cols, title = "K = 10",
         plot = TRUE, return_graph = FALSE)
legend(x=-3, y=0, legend = levels(clusters), col = col, pch = 16)

```


Remove a proportion of cells from one of the terminal cell types..  
```{r removing some beta cells}
not.beta.bars = names(clusters)[which(clusters != "Beta")]
set.seed(2)
some.beta.bars = sample(names(clusters)[which(clusters == "Beta")],200)
some.beta.bars = names(clusters)[which(clusters == "Beta")][seq(1,length(which(clusters == "Beta")),by=4)]
curr.bars = c(not.beta.bars,some.beta.bars)
pca.names.sub = cell.names[cell.names %in% curr.bars]
all.logODS.sub = all.logODS[pca.names.sub,]
pca.cols.sub = cell.cols[pca.names.sub]

## run pca without current cell type 
pca.sub = svds(A = all.logODS.sub, k=50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var.sub = pca.sub$d
#plot(var.sub) # ~4 components 

emb.pca.sub = pca.sub$u[,1:2]
row.names(emb.pca.sub) = row.names(all.logODS.sub)
plot(emb.pca.sub, col = pca.cols.sub, pch = 16, xlab = "PC1", ylab = "PC2", main = "PCA on subsampled data \nw/o EP high cells", xlim = c(-0.05,0.07))
legend(x=0.04, y=0.06, legend = levels(clusters), col = col, pch = 16)

## scores of current and projected 
u.currTypes = pca.sub$u #scores
v.currTypes = pca.sub$v #loads
row.names(v.currTypes) = odsGenes

common.genes = sapply(row.names(curr), function(x) x %in% odsGenes)
common.genes.names = rownames(curr)[common.genes]
curr.pca = curr[common.genes,pca.names.sub]
v.sub = v.currTypes[row.names(curr.pca),]

par(mfrow = c(1,2))

curr.scores = t(curr.pca) %*% v.sub
plot(curr.scores[,1:2], col = pca.cols.sub, main = 'Observed')

proj.pca = proj[common.genes,pca.names.sub]
proj.scores = t(proj.pca) %*% v.sub
plot(proj.scores[,1:2], col = pca.cols.sub, main = 'Projected')

## make graph using new current and projected scores 
currSub.names = cell.names.sub[cell.names.sub %in% curr.bars]
currSub.n = length(currSub.names)
currSub.cols = cell.cols[currSub.names]

currSub.currScores = t(curr.scores[currSub.names,])
currSub.projScores = t(proj.scores[currSub.names,])

set.seed(1)
graphViz(observed = currSub.currScores, projected = currSub.projScores,
         k = 10, distance_metric = "L2", similarity_metric = "cosine", similarity_threshold = 0.25, weighted = TRUE,
         cell.colors = currSub.cols, title = "K = 10",
         plot = TRUE, return_graph = FALSE)
legend(x=1.5, y=2.2, legend = levels(clusters), col = col, pch = 16)

```







