---
title: "Cycle Simulation - Testing Distance Threshols"
author: "LylaAtta"
date: "11/12/2020"
output: html_document
---

adapted from Jean's simulation  
looking at "unwrapping" of cycle in velocity based embedding and effect of changing distance weights  

```{r setup, include=FALSE}
#using velo_splatter evironment 
knitr::opts_chunk$set(echo = FALSE)
library(Rcpp)
#library(reticulate)
library(igraph)
library(matie)
library(RANN)
library(velocyto.R)
library(MUDAN)
library(RSpectra)
library(umap)
library(Rtsne)
library(destiny)
library(scater)
#library(dyngen)
#library(dyntoy)
source("projectedNeighbors_weightedCD.R")
```


```{r jeantest1}
## make circle like cell cycle
par(mfrow=c(1,1))
x <- matrix(rnorm(1000),nc=2)
y <- x/sqrt(rowSums(x^2))
## add some jitter
obs1 <- t(y)
obs <- jitter(obs1, amount = 0.25)
## order points counterclockwise
angle <- atan2(obs[2,], obs[1,])
#angle

obs <- obs[, order(angle)]
#obs
## rainbow
col = colorRampPalette(c(rainbow(10)))(ncol(obs))
labels <- paste0('cell', 1:ncol(obs))
## plot
plot(t(obs),col=col, pch=16)
text(t(obs[,seq(175,225,5)]), labels[seq(175,225,5)])

colnames(obs) <- labels
```

```{r, eval = FALSE}
angle1 <- atan2(obs1[2,], obs1[1,])
obs1 = obs1[,order(angle1)]
plot(t(obs1), col = col, pch = 16)
```


Remove some transient cells

```{r jeantestremove}
cells.keep <- setdiff(labels, paste0('cell', 200:300))
# cells.keep

labels <- labels[which(labels %in% cells.keep)]
obs <- obs[,cells.keep]
plot(t(obs),col=col, pch=16)
text(t(obs[,seq(150,199,by=5)]), labels[seq(150,199,by=5)])
text(t(obs[,seq(200,250,by=7)]), as.character(seq(200,250,by=7))) #labels[seq(200,250,by=7)]

```

Simulate lower dimensional representation of future transcriptional state

```{r jeantest2}
## rotate circle slightly
f = pi*0.1 # adjust as needed
exp = t(obs)
exp[,1] = obs[1,]*cos(f) - obs[2,]*sin(f)
exp[,2] = obs[2,]*cos(f) + obs[1,]*sin(f)
exp = t(exp)

plot(t(obs),col=col, pch=16)
points(t(exp),col=col)
arrows(t(obs)[,1],t(obs)[,2],t(exp)[,1],t(exp)[,2])

colnames(exp) <- labels
```

Try different embeddings

```{r jeantest_veloviz}
#, fig.width=7,fig.height=7
k = 50
## Lyla's FDG
set.seed(1)
gsim = graphViz(obs, exp, k, cell.colors=col, distance_weight = 1, similarity_threshold = -1, weighted=TRUE, plot = TRUE, return_graph = TRUE)
#plot(gsim$fdg_coords, main = "FDG: vertex coordinates", col=col, pch=16)
#text(gsim$fdg_coords+0.1, labels = labels)

```


# Behavior of weights with weights 
```{r, fig.width=7.5, fig.height=12, eval = FALSE}
js = c(0.1, 0.25, 0.5, 1) #jitter amounts 
as = c(0.01, 0.05, 0.1, 0.5) #angles to rotate for exp
ws = c(10,1,0.1,0.01,0.001)

j01 = list()
ks = c(5,10,50,100)

par(mfrow=c(5,2))
for (j in js[2]){
  ## make circle like cell cycle
  x <- matrix(rnorm(1000),nc=2)
  y <- x/sqrt(rowSums(x^2))
  ## add some jitter
  obs <- t(y)
  obs <- jitter(obs, amount = j)
  ## order points counterclockwise
  angle <- atan2(obs[2,], obs[1,])
  
  obs <- obs[, order(angle)]
  ## rainbow
  col = colorRampPalette(c(rainbow(10)))(ncol(obs))
  labels <- paste0('cell', 1:ncol(obs))
  ## plot
  #plot(t(obs),col=col, pch=16)
  #text(t(obs), labels)
  
  colnames(obs) <- labels
  
  #remove some cells 
  cells.keep <- setdiff(labels, paste0('cell', 200:300))

  labels <- labels[cells.keep]
  obs <- obs[,cells.keep]
  #plot(t(obs),col=col, pch=16)
  
  ## rotate circle slightly
  for (a in as[3]){
    f = pi*a # adjust as needed
    exp = t(obs)
    exp[,1] = obs[1,]*cos(f) - obs[2,]*sin(f)
    exp[,2] = obs[2,]*cos(f) + obs[1,]*sin(f)
    exp = t(exp)
    
    # plot(t(obs),col=col, pch=16)
    # points(t(exp),col=col)
    # arrows(t(obs)[,1],t(obs)[,2],t(exp)[,1],t(exp)[,2])
    
    colnames(exp) <- labels
    #par(mfrow=c(2,4))
    for(k in ks[2]){
      
      for(w in ws){
        set.seed(1)
        gsim = graphViz(obs, exp, k, cell.colors=col, distance_weight = w, similarity_threshold = -1, weighted=TRUE, plot = FALSE, return_graph = TRUE)
        j01[[as.character(j)]] = gsim
        plot(gsim$fdg_coords, main = paste0("FDG: vertex coordinates\nJitter:",j,"Angle:",a,"*pi, K:",k,"Weight:",w), col=col, pch=16)
        
        g <- gsim$graph
        V(g)$label = NA
        V(g)$size = 2
        E(g)$arrow.size = 0.5
        E(g)$color = rgb(0,0,0,0.1)
        plot(g)
      }
      
      
    }
    
  }
  
}


```


Keeping top 10% of edges  
```{r}
source("projectedNeighbors_weightedCD.R")
set.seed(1)
gsim = graphViz(obs, exp, k = 50, cell.colors=col, distance_weight = 1, distance_threshold = 0.1, similarity_threshold = -1, weighted=TRUE, plot = TRUE, return_graph = TRUE)
```
```{r, fig.width=6, fig.height=8}
ts = c(1, 0.8, 0.5, 0.4, 0.2, 0.1)

par(mfrow = c(3,2))
for (t in ts){
  set.seed(1)
  gsim = graphViz(obs, exp, k = 50, cell.colors=col, distance_weight = 1, distance_threshold = t, similarity_threshold = -1, weighted=TRUE, plot = TRUE, return_graph = TRUE, title = paste("Distance threshold",t))
}

```












