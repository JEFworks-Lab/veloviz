---
title: "graphViz U2O5"
author: "LylaAtta"
date: "8/19/2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(igraph)
library(matie)
library(RANN)
library(velocyto.R)
rvel.cd = readRDS("rvelcd.rds")
emb.test = readRDS("embTest.rds")
cell.color = readRDS("cellColor.rds")
pcaInfo = readRDS("pcaInfo.rds")
```

RNA velocity (steady state model) projected on PCA embedding. 
```{r}
show.velocity.on.embedding.cor(scale(emb.test), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)

```

#### Constructing embedding from velocity projections:

For each observed cell_i, find the nearest neighbor, cell_{nn,i}, to it's projected state p_i in the observed cells excluding cell_i. Build a force directed graph where edges are pointing from cell_i to cell_{nn,i}. 

Find neighbors, calculate edge weights  
```{r}
curr = rvel.cd$current #observed cells 
proj = rvel.cd$projected #projected states

ncells = ncol(curr)
cellidx = sapply(seq(1:ncells), function(x) nn2(t(curr[,-x]),t(proj[,x]),k=1)$nn.idx) #index of cell_{nn,i}
celldist = sapply(seq(1:ncells), function(x) nn2(t(curr[,-x]),t(proj[,x]),k=1)$nn.dist) #distance between p_i and cell_{nn,i}


for (c in seq(1,length(cellidx))){
  if (cellidx[c]>=c){
    cellidx[c] = cellidx[c] + 1
  }
}

edgeList = cbind(seq(1,ncells),cellidx)
edgeWeights = 1/(1+celldist)
```

G0: force directed graph with no edge weights 
```{r G0}
g0 = graph_from_edgelist(edgeList,directed =TRUE)
g0FD = layout_with_fr(g0)
colnames(g0FD) = c("C1","C2")
rownames(g0FD) = colnames(curr)

show.velocity.on.embedding.cor(scale(g0FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)
```

G1: force directed graph with edge weights 
```{r G1}
g1 = graph_from_edgelist(edgeList, directed = TRUE)
edge.attributes(g1)$weight = edgeWeights
g1FD = layout_with_fr(g1)
colnames(g1FD) = c("C1","C2")
rownames(g1FD) = colnames(curr)

show.velocity.on.embedding.cor(scale(g1FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)
```

G2: force directed graph with no edge weights, starting with pca coords
```{r G2}
g2 = graph_from_edgelist(edgeList,directed =TRUE)
g2FD = layout_with_fr(g2,emb.test)
colnames(g2FD) = c("C1","C2")
rownames(g2FD) = colnames(curr)

show.velocity.on.embedding.cor(scale(g2FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)
```

G3: force directed graph with edge weights, starting with pca coords 
```{r G3}
g3 = graph_from_edgelist(edgeList, directed = TRUE)
edge.attributes(g3)$weight = edgeWeights
g3FD = layout_with_fr(g3,emb.test)
colnames(g3FD) = c("C1","C2")
rownames(g3FD) = colnames(curr)

show.velocity.on.embedding.cor(scale(g3FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)
```

#### Subsample U2O5 data:
```{r subsample}
pcaAngle = acos(emb.test[,2]/sqrt(emb.test[,1]^2 + emb.test[,2]^2))
pcaAngleOrd = order(pcaAngle)
pcaAngle = pcaAngle[pcaAngleOrd]
emb.test.ord = emb.test[pcaAngleOrd,]
emb.test.sub.names = rownames(emb.test.ord)[seq(1,1368,by=10)]
emb.test.sub = emb.test.ord[emb.test.sub.names,]
cell.color.sub = cell.color[emb.test.sub.names]
plot(emb.test.sub, col = cell.color.sub, pch = 16)

show.velocity.on.embedding.cor(scale(emb.test.sub), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)

curr.sub = curr[,emb.test.sub.names]
proj.sub = proj[,emb.test.sub.names]

ncells.sub = ncol(curr.sub)

```

####
Make graph for sample subset: 
```{r subsample graph}
cellidx.sub = sapply(seq(1:ncells.sub), function(x) nn2(t(curr.sub[,-x]),t(proj.sub[,x]),k=1)$nn.idx) #index of cell_{nn,i}
celldist.sub = sapply(seq(1:ncells.sub), function(x) nn2(t(curr.sub[,-x]),t(proj.sub[,x]),k=1)$nn.dist) #distance between p_i and cell_{nn,i}


for (c in seq(1,length(cellidx.sub))){
  if (cellidx.sub[c]>=c){
    cellidx.sub[c] = cellidx.sub[c] + 1
  }
}

edgeList.sub = cbind(seq(1,ncells.sub),cellidx.sub)
edgeWeights.sub = 1/(1+celldist.sub)
```

G4: force directed graph with no edge weights on subsample 
```{r G4}
g4 = graph_from_edgelist(edgeList.sub,directed =TRUE)
V(g4)$color = cell.color.sub 
plot(g4)
g4FD = layout_with_fr(g4)
colnames(g4FD) = c("C1","C2")
rownames(g4FD) = colnames(curr.sub)

show.velocity.on.embedding.cor(scale(g4FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)
text(scale(g4FD)+0.1,labels = seq(1,dim(g4FD)[1]))
```

G5: force directed graph with no edge weights on subsample 
```{r G5}
g5 = graph_from_edgelist(edgeList.sub,directed =TRUE)
V(g5)$color = cell.color.sub 
edge.attributes(g5)$weight = edgeWeights.sub
plot(g5)
g5FD = layout_with_fr(g5)
colnames(g5FD) = c("C1","C2")
rownames(g5FD) = colnames(curr.sub)

show.velocity.on.embedding.cor(scale(g5FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=2)
text(scale(g5FD)+0.1,labels = seq(1,dim(g4FD)[1]))
```

#### New distance function 

```{r new dist function}
myDist = function(cell_i,proj_i,nn_i){
  #cell_i: current vertex
  #proj_i: projected state of cell i based on velocity
  #nn_i: putative nearest neighbor to cell_i 
  
  #distance to minimize is between proj_i and nn_i: d = nn_i - proj_i 
  #angle to minimize is between velocity (v = proj_i - cell_i) and cell_i --> nn_i (n = nn_i - cell_i)
  
  d = nn_i - proj_i
  #print(paste("d",d))
  v = proj_i - cell_i 
  #print(paste("v",v))
  n = nn_i - cell_i 
  #print(paste("n",n))
  
  invEuc = 1/sqrt(sum(d^2))
  #print(paste0("invEuc",invEuc))
  negCos = -1*(v %*% n)/(sqrt(sum(v^2))*sqrt(sum(n^2))) 
  #print(paste0("negCos",negCos))
  #print(paste0("myDist",invEuc*negCos))
  dists = list()
  dists[["invEuc"]] = invEuc
  dists[["negCos"]] = negCos
  dists[["myDist"]] = invEuc*negCos
  return(dists)
}
```

```{r test new dist}

pts = matrix(c(2,2,2,4,2,3,2,4,6,2,0,3), ncol =2)

newDists = matrix(NA,nrow = 4, ncol = 1)
for (i in seq(1,4)){
  print(i)
  print(pts[2+i,])
  newDists[i] = myDist(pts[1,],pts[2,],pts[2+i,])
}


plot(pts, col = c("black","blue","red","red","red","red"),xlim = c(0,4.5),ylim = c(-0.5,6.5), pch = c(16,16,16))
text(pts-0.2,labels = c("cell_i","proj_i","nn_i","nn_i","nn_i","nn_i"))
text(pts+0.2, labels = c("","",newDists))
legend(3.5,6,legend = c("cell_i","proj_i","nn_i"), col = c("black","blue","red"),pch = c(16,16,16))


```

```{r projected neighbor based on new dist}
# k nearest neighbors based on projected states and given custom distance metric 
projectedNeighbors = function(observed,projected){
  #observed: genes x cells matrix of observed cells 
  #projected: genes x cells matrix of projected states of cells in observed (same order)
  
  observed = t(observed)
  projected = t(projected)
  n = nrow(observed)
  
  nn_idx = matrix(NA,nrow=nrow(observed), ncol = 1)
  all_dists = matrix(NA,nrow = n, ncol = n)
  all_invEuc = matrix(NA,nrow = n, ncol = n)
  all_negCos = matrix(NA,nrow = n, ncol = n)
  
  for (i in seq(1,nrow(observed))){
    cell_i = observed[i,] #current cell whose projected neighbor we want to find
    proj_i = projected[i,] #projected state of cell i 
    obs_exc_i = observed[-i,] #cell_i can't be its own projected neighbor - remove from consideration
    
    nn_dists_i = matrix(NA, nrow=nrow(obs_exc_i), ncol = 1) #distances of all other observed cells from cell_i
    nn_invEuc_i = matrix(NA, nrow=nrow(obs_exc_i), ncol = 1) #invEuc component
    nn_negCos_i = matrix(NA, nrow=nrow(obs_exc_i), ncol = 1) #invEuc component
    
    #calculate distances between cell_i and all other cells j [USE SAPPLY HERE???]
    for (j in seq(1,nrow(obs_exc_i))){
      nn_j = obs_exc_i[j,] 
      dist_j = myDist(cell_i,proj_i,nn_j) #distance between cell_i and current cell_j
      nn_dists_i[j] = dist_j$myDist
      nn_invEuc_i[j] = dist_j$invEuc
      nn_negCos_i[j] = dist_j$negCos
    }
    
    
    #add cell_i's dists to all_dists 
    all_dists[i,-i] = nn_dists_i
    all_invEuc[i,-i] = nn_invEuc_i
    all_negCos[i,-i] = nn_negCos_i
    
    #find index of minimum distance between cell_i and other cells --> nn_i 
    min_dist_idx = which(nn_dists_i==min(nn_dists_i))
    #correct index 
    if (min_dist_idx>=i){
      min_dist_idx = min_dist_idx + 1
    }
    nn_idx[i] = min_dist_idx
  }
  dist_comp = list()
  dist_comp[["invEuc"]] = all_invEuc
  dist_comp[["negCos"]] = all_negCos
  out = list()
  out[['NNs']] = nn_idx
  out[['all_dists']] = all_dists
  out[["dist_comp"]] = dist_comp
  return(out)
}

```

```{r test new projected neighbor function}
obs = t(matrix(c(2,2,2,3,4,0,2,6,3,2), ncol =2))
exp = t(matrix(c(3,2,3,3,2,1,4,5,1,4), ncol =2))
obs_lab = paste("cell",seq(1,5))
exp_lab = paste("proj",seq(1,5))

plot(t(obs),xlim = c(1,4.5),ylim = c(-0.5,6.5), pch = c(16,16,16), col = "red")
points(t(exp), xlim = c(0,4.5),ylim = c(-0.5,6.5), pch = c(16,16,16), col = "blue")
text(t(obs)-0.2,labels = obs_lab)
text(t(exp)-0.2,labels = exp_lab)

nns = projectedNeighbors(obs,exp)

text(t(obs)+0.2, labels = paste("proj neighbor:",nns))

edgeListTest = cbind(seq(1:5),nns)
newGtest = graph_from_edgelist(edgeListTest,directed =TRUE)
plot(newGtest)
gTestFD = layout_with_fr(newGtest)
plot(gTestFD, main = "FDG")
text(gTestFD-0.1,labels = paste("cell",seq(1:5)))

```

G6: force directed graph with no edge weights on subsample 
```{r}
subCellsNewNNs = projectedNeighbors(curr.sub,proj.sub)
subAllDists = subCellsNewNNs$all_dists
subCellsNewEdgeList = cbind(seq(1,ncells.sub),subCellsNewNNs$NNs)
#subCellsNewNNs = projectedNeighbors(curr,proj)
#subCellsNewEdgeList = cbind(seq(1,ncells),subCellsNewNNs)

g6 = graph_from_edgelist(subCellsNewEdgeList,directed =TRUE)
V(g6)$color = cell.color.sub 
#V(g6)$color = cell.color
plot(g6)
g6FD = layout_with_fr(g6,dim=2)
colnames(g6FD) = c("C1","C2")
rownames(g6FD) = colnames(curr.sub)
#rownames(g6FD) = colnames(curr)
#plot(g6FD, col = cell.color, pch = 16)

show.velocity.on.embedding.cor(scale(g6FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1)
text(scale(g6FD)+0.1,labels = seq(1,dim(g6FD)[1]))

show.velocity.on.embedding.cor(scale(emb.test.sub), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1)
text(scale(emb.test.sub)[rownames(g6FD),]+0.1,labels = seq(1,dim(g6FD)[1]))

```

```{r look at distribution of distances and min distances }
hist(subAllDists,breaks = 50)
allDistsMins = sapply(seq(1:ncol(subAllDists)), function(x) min(subAllDists[x,], na.rm = TRUE))
hist(allDistsMins,breaks = 50)
hist(subAllDists[1,],breaks = 69)


```

#### Use PCA coords to make graph 
```{r calculate score of projected cell states}
pca = pcaInfo$pca
sigma = diag(pca$d)
#plot(pca$d,ylab = "Variance Explained", xlab = "PC")
u = pca$u
v = pca$v
row.names(v) = pcaInfo$geneNames

common.genes = sapply(row.names(curr), function(x) x %in% pcaInfo$geneNames)
curr.pca = curr[common.genes,]
vSub = v[row.names(curr.pca),]

par(mfrow = c(1,2))

curr.scores = t(curr.pca) %*% vSub
plot(curr.scores[,1:2], col = cell.color, main = 'Observed')

proj.pca = proj[common.genes,]
proj.scores = t(proj.pca) %*% vSub
plot(proj.score[,1:2], col = cell.color, main = 'Projected')


```

G7: graph from PCA coordinates 
```{r use PCA coordinates to make graph instead of coordinates in gene expression space}
set.seed(1)
curr.scores.cellsub = t(curr.scores[emb.test.sub.names,])
proj.scores.cellsub = t(proj.scores[emb.test.sub.names,])

pcaSubNNs = projectedNeighbors(curr.scores.cellsub,proj.scores.cellsub)
pcaNewEdgeList = cbind(seq(1,ncells.sub),pcaSubNNs$NNs)

g7 = graph_from_edgelist(pcaNewEdgeList,directed =TRUE)
V(g7)$color = cell.color.sub 
#V(g6)$color = cell.color
plot(g7)
g7FD = layout_with_fr(g7,dim=2)
colnames(g7FD) = c("C1","C2")
rownames(g7FD) = colnames(curr.scores.cellsub)
#rownames(g6FD) = colnames(curr)
#plot(g6FD, col = cell.color, pch = 16)

plot(scale(g7FD),col = cell.color.sub, pch = 16, main = "FDG cell coordinates")

show.velocity.on.embedding.cor(scale(g7FD), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1, main = "FDG embedding")
text(scale(g7FD)+0.1,labels = seq(1,dim(g7FD)[1]))

show.velocity.on.embedding.cor(scale(emb.test.sub), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1, main = "PCA embedding")
text(scale(emb.test.sub)[rownames(g7FD),]+0.1,labels = seq(1,dim(g7FD)[1]))



```

```{r look at distribution of distances with increasing PCs }

curr.pc.dists = pcaSubNNs$all_dists
hist(curr.pc.dists,breaks = 100, ylim = c(0,40))
allDistsMins = sapply(seq(1:ncol(curr.pc.dists)), function(x) min(curr.pc.dists[x,], na.rm = TRUE))
hist(allDistsMins,breaks = 50)
hist(curr.pc.dists[1,],breaks = 50)

curr.pc.invEuc = pcaSubNNs$dist_comp$invEuc
hist(curr.pc.invEuc, breaks = 50,ylim = c(0,50))

curr.pc.negCos = pcaSubNNs$dist_comp$negCos
hist(curr.pc.negCos, breaks = 100)
```

