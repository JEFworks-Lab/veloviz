---
title: "graph_u2osViz"
author: "LylaAtta"
date: "9/8/2020"
output: html_document
---
Trying graph-based visualization on U2OS data. 


#### Setup and get data 
```{r setup, include=FALSE}
#using velocyto2 evironment 
knitr::opts_chunk$set(echo = FALSE)
library(reticulate)
library(igraph)
library(matie)
library(RANN)
library(velocyto.R)
library(MUDAN)
library(RSpectra)
library(umap)
library(sva)
source("projectedNeighbors.R")

#rvel.cd = readRDS("rvelcd.rds")
#emb.test = readRDS("embTest.rds")
#cell.color = readRDS("cellColor.rds")
#pcaInfo = readRDS("pcaInfo.rds")

#curr = rvel.cd$current #observed cells 
#proj = rvel.cd$projected #projected states
```

```{r load data, include = FALSE}
cellExp = read.csv("../data/S12_cell_gexp.csv", header = TRUE)
rownames(cellExp) = cellExp$X
cellExp = cellExp[,2:ncol(cellExp)]

nucExp = read.csv("../data/S14_nuc_gexp.csv", header = TRUE)
rownames(nucExp) = nucExp$X
nucExp = nucExp[,2:ncol(nucExp)]

cytoExp = cellExp - nucExp

geneInfo = read.csv("../data/S1_codebook.csv", header = TRUE, stringsAsFactors = FALSE)
longGenes = geneInfo[1:9050,'name'] #non-overlapping probes
shortGenes = geneInfo[9279:10278,]$name #overlapping probes
blankGenes = geneInfo[grepl('Blank',geneInfo$name),]$name #blank controls 

#only use long genes for analysis 
longGenes.names = as.character(longGenes)
allExp.longGenes = cellExp[longGenes.names,]
nucExp.longGenes = nucExp[longGenes.names,]
cytoExp.longGenes = cytoExp[longGenes.names,]

```

#### Normalization and dimensional reduction 

```{r cleanup and normalization for dim red, results="hide", include = FALSE}
allExp = allExp.longGenes

#batch annotation 
batch = sapply(colnames(allExp), function(x) strsplit(x, '_')[[1]][1])
batch = factor(batch)

#filter genes with low expression 
goodGenes = rowMeans(allExp) > 1
allExp = allExp[goodGenes,]

#batch correct
allExp.batch = ComBat(as.matrix(allExp),batch[colnames(allExp)])
allExp.batch[allExp.batch<0] = 0 #set negative expression to 0

#CPM normalize 
allExp.cpm = normalizeCounts(allExp.batch)

#Normalize variance 
allExp.norm = normalizeVariance(allExp.cpm, details = TRUE, plot = TRUE)
odsGenes = rownames(allExp.norm$mat)[allExp.norm$ods] #overdispersed genes

#Over dispersed genes, log normalize
allExp.logODS = log10(as.matrix(t(allExp.norm$mat[allExp.norm$ods,]))+1)
cell.names = rownames(allExp.logODS)
nCells = length(cell.names)
```

```{r dimensional reduction}
pca = svds(A = allExp.logODS, k=50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var = pca$d
#plot(var) # ~5 components 

pcsToKeep = pca$u[,1:30]
row.names(pcsToKeep) = cell.names
emb.pca = pca$u[,1:2]
row.names(emb.pca) = cell.names
#plot(emb.pca, pch = 16, xlab = "PC1", ylab = "PC2")
```
**PCA**:  
```{r clustering, results="hide"}
#community detection 
com = getComMembership(pcsToKeep, k=300, method = igraph::cluster_louvain)
cluster.label = factor(com)
cell.cols = MUDAN:::fac2col(cluster.label)
plot(scale(emb.pca), pch=16, xlab = 'PC1', ylab = 'PC2', col = cell.cols, main="PCA: All U2OS Data")
```


**UMAP:**  
```{r umap}
set.seed(1)
emb.umap = umap(pcsToKeep)$layout
rownames(emb.umap) = cell.names
plot(scale(emb.umap), col = cell.cols, pch = 16, xlab = 'UMAP X', ylab = 'UMAP Y', main="UMAP: All U2OS Data")

```

#### Velocity 
Calculating velocity using `velocyto` and projecting on PCA and UMAP embeddings  
```{r velocity, results="hide"}
subcells = names(batch)
cyto = as.matrix(cytoExp.longGenes[,subcells])
nuc = as.matrix(nucExp.longGenes[,subcells])

cell.dist = as.dist(1-cor(t(pcsToKeep[subcells,])))
fit.quantile = 0.05
#rvel.cd = gene.relative.velocity.estimates(cyto, nuc, deltaT = 1, kCells = 30, cell.dist = cell.dist, fit.quantile = fit.quantile)
# saveRDS(rvel.cd,file = "rvelcd.rds")
rvel.cd = readRDS("rvelcd.rds")
curr = rvel.cd$current
proj = rvel.cd$projected

#plot velocity projections on PCs
show.velocity.on.embedding.cor(scale(emb.pca), rvel.cd, n=100, scale='sqrt', cell.colors=cell.cols,
                               cex=1, arrow.scale=1, show.grid.flow=TRUE,
                               min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1,
                               xlab = 'PC1', ylab = 'PC2', main="Velocity Projection on PCA")

#plot velocity projection on UMAP
show.velocity.on.embedding.cor(scale(emb.umap), rvel.cd, n=100, scale='sqrt', cell.colors=cell.cols,
                               cex=1, arrow.scale=1, show.grid.flow=TRUE,
                               min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1,
                               xlab = 'UMAP X', ylab = 'UMAP Y', main="Velocity Projection on UMAP")


```


#### Subsample 
Downsample to make things faster..  
```{r subsample, results = 'hide', fig.width=5, fig.height=5} 
#fig.width=3, fig.height=3
#we want to sample equally from all regions of the pca plot: order cells by angle from +ve y axis, then sample uniformally 

#order cells 
pcaAngle = acos(emb.pca[,2]/sqrt(emb.pca[,1]^2 + emb.pca[,2]^2))
pcaAngleOrd = order(pcaAngle)
pcaAngle = pcaAngle[pcaAngleOrd]
emb.pca.ord = emb.pca[pcaAngleOrd,]

#subsample 
cell.names.sub = rownames(emb.pca.ord)[seq(1,nCells,by=5)] #### CHANGE HERE to change size of sample
emb.pca.sub = emb.pca.ord[cell.names.sub,]
cell.cols.sub = cell.cols[cell.names.sub]
plot(emb.pca.sub, col = cell.cols.sub, pch = 16, xlab = 'PC1', ylab = 'PC2', main="PCA: Subsampled U2OS Data on\n embedding from full data")
nCells.sub = length(cell.names.sub)


#show.velocity.on.embedding.cor(scale(emb.test.sub), rvel.cd, n=100, scale='sqrt', cell.colors=cell.color,cex=1, arrow.scale=1, show.grid.flow=TRUE, min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1, return.details = TRUE)
#curr.sub = curr[,emb.test.sub.names]
#proj.sub = proj[,emb.test.sub.names]

```

Calculate scores of observed and projected states in PCA space:  
```{r calculate score of projected cell states, fig.width=8, fig.height=5 }
u = pca$u
v = pca$v
row.names(v) = odsGenes

common.genes = sapply(row.names(curr), function(x) x %in% odsGenes)
common.genes.names = rownames(curr)[common.genes]
curr.pca = curr[common.genes,]
vSub = v[row.names(curr.pca),]

par(mfrow = c(1,2))

curr.scores = t(curr.pca) %*% vSub
plot(curr.scores[,1:2], col = cell.cols, main = 'Observed',xlab = 'PC1', ylab = 'PC2')

proj.pca = proj[common.genes,]
proj.scores = t(proj.pca) %*% vSub
plot(proj.scores[,1:2], col = cell.cols, main = 'Projected',xlab = 'PC1', ylab = 'PC2')


```

#### FDG Embedding  
Construct FDG embedding using PC1 and PC2  
Distance metric: L2, similarity: cosine, k=20, similarity threshold=0.25  
```{r graph, fig.width=8, fig.height=5, results="hide"}
vel = rvel.cd
deltaExp = vel$deltaE[common.genes.names,cell.names.sub] 

set.seed(1)
curr.scores.sub = t(curr.scores[cell.names.sub,c(1,2)]) #### change here to change number of PCs included 
proj.scores.sub = t(proj.scores[cell.names.sub,c(1,2)]) ####

graphViz(curr.scores.sub,proj.scores.sub,20,"L2","cosine",0.25,cell.cols.sub)


```

#### Compare FDG to PCA and UMAP embeddings  
Make PCA and UMAP embedding for sample subsample used for FDG  
```{r pca and umap on subset}
#pca and umap on subsample 
#pca
all.logODS = readRDS("mat_u2os.rds")
all.logODS.sub = all.logODS[cell.names.sub,]
pca.sub = svds(A = all.logODS.sub,k = 50, opts = list(center = TRUE, scale = FALSE, maxitr = 2000, tol = 1e-10))
var.sub = pca.sub$d
#plot(var.sub) # 3 components
emb.pca.sub = pca.sub$u[,1:2]
row.names(emb.pca.sub) = row.names(all.logODS.sub)
plot(emb.pca.sub,col = cell.cols.sub, pch = 16, xlab = "PC1", ylab = "PC2",main = "PCA on subsampled U2OS data")

#plot velocity projections on PCs
show.velocity.on.embedding.cor(scale(emb.pca.sub), rvel.cd, n=100, scale='sqrt', cell.colors=cell.cols.sub,
                               cex=1, arrow.scale=1, show.grid.flow=TRUE,
                               min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1)


#umap
set.seed(1)
pcs.sub = pca.sub$u
emb.umap.sub = umap(emb.pca.sub)$layout
row.names(emb.umap.sub) = row.names(all.logODS.sub)
plot(scale(emb.umap.sub),col = cell.cols.sub, pch = 16,  xlab = "UMAP X", ylab = "UMAP Y",main = "UMAP on subsampled U2OS data")

#plot velocity projection on UMAP
show.velocity.on.embedding.cor(scale(emb.umap.sub), rvel.cd, n=100, scale='sqrt', cell.colors=cell.cols.sub,
                               cex=1, arrow.scale=1, show.grid.flow=TRUE,
                               min.grid.cell.mass=0.5, grid.n=30, arrow.lwd=1)
```

Calculate consistency score for all embeddings 
```{r consistency score comparisons, results="hide"}
#consistency scores for pca embedding 
set.seed(1)

pcaCon = consistency(emb.pca.sub,deltaExp,20,FALSE)
umapCon = consistency(emb.umap.sub,deltaExp,20,FALSE)

fdgCoords = graphViz(curr.scores.sub,proj.scores.sub,20,"L2","cosine",0.25,cell.cols.sub,plot = FALSE,return_graph = TRUE)$fdg_coords
fdgCon = consistency(fdgCoords,deltaExp,20,FALSE)

```

```{r, fig.width = 5, fig.height = 7}
par(mfrow = c(3,1))
x = c(-0.2,1)
y = c(0,15)
xt = "Cell Consistency Score"
hist(pcaCon,breaks = 100, col = "red",xlim = x, ylim = y,  xlab =  xt, main = "PCA Embedding Consistency")
hist(umapCon,breaks = 100, col = "green", xlim = x,ylim = y, xlab =  xt, main = "UMAP Embedding Consistency")
hist(fdgCon, breaks = 100, col = "blue",xlim = x, ylim = y, xlab =  xt, main = "FDG Embedding Consistency")

print("Mean consistency score for PCA, UMAP, FDG embeddings")
mean(pcaCon)
mean(umapCon)
mean(fdgCon)
print("Median consistency score for PCA, UMAP, FDG embeddings")
median(pcaCon)
median(umapCon)
median(fdgCon)
```



#### Varying graph parameters 
Calculating consistency scores for FDG embeddings constructed with different graph parameters (k, similarity threshold):  
Number of out edges k:  
```{r changing k, results = 'hide'}
#using distance=L2, similarity=cosine, threshold=0.25
ks = c(1,5,10,20,50,100)
conScores_k = matrix(NA,nrow = nCells.sub,ncol=length(ks))
for (i in seq(1,length(ks))){
  k = ks[i]
  set.seed(5)
  currG = graphViz(curr.scores.sub,proj.scores.sub,k,"L2","cosine",0.25,cell.cols.sub,paste("K = ",k),plot = FALSE,return_graph = TRUE)
  currCoords = currG$fdg_coords
  curr.con = consistency(currCoords, deltaExp,20,FALSE)
  conScores_k[,i] = curr.con
  # col.gradient = colorRampPalette(c('blue','red'))
  # cons.col = col.gradient(ncells.sub)[as.numeric(cut(curr.con,breaks = ncells.sub))]
  # plot(currCoords,col = cons.col,pch = 16)
}

par(mfrow = c(3,2))
y = c(0,17)
hist(conScores_k[,1],col="red",breaks = 100,xlim=c(-0.5,1),ylim=y,xlab = "Cell Consistency Score",main="K = 1")
hist(conScores_k[,2],col="blue",breaks = 100, xlim=c(-0.5,1),ylim=y,xlab = "Cell Consistency Score",main="K = 5")
hist(conScores_k[,3],col="green",breaks = 100, xlim=c(-0.5,1),ylim=y,xlab = "Cell Consistency Score",main="K = 10")
hist(conScores_k[,4],col="yellow",breaks = 100, xlim=c(-0.5,1),ylim=y,xlab = "Cell Consistency Score",main="K = 20")
hist(conScores_k[,5],col="black",breaks = 100, xlim=c(-0.5,1),ylim=y,xlab = "Cell Consistency Score",main="K = 50") #add = TRUE
hist(conScores_k[,6],col="cyan",breaks = 100, xlim=c(-0.5,1),ylim = y,xlab = "Cell Consistency Score",main="K = 100") #add = TRUE

print("Mean consistency scores")
print(colMeans(conScores_k))
print("Median consistency scores")
print(sapply(c(1:6), function(x) median(conScores_k[,x])))
```

Similarity threshold:  
```{r changing similarity threshold, results = 'hide'}
#using k=10, distance=L2, similarity=cosine
ts = c(-1, 0, 0.25, 0.5, 0.75, 0.9)
conScores_t = matrix(NA,nrow = nCells.sub,ncol=length(ts))
for (i in seq(1,length(ts))){
  set.seed(1)
  t = ts[i]
  currG = graphViz(curr.scores.sub,proj.scores.sub,10,"L2","cosine",t,cell.cols.sub,paste("Similarity Threshold = ",t),plot = TRUE,return_graph = TRUE)
  currCoords = currG$fdg_coords
  curr.con = consistency(currCoords, deltaExp,20,FALSE)
  conScores_t[,i] = curr.con
  # col.gradient = colorRampPalette(c('blue','red'))
  # cons.col = col.gradient(ncells.sub)[as.numeric(cut(curr.con,breaks = ncells.sub))]
  # plot(currCoords,col = cons.col,pch = 16)
}

par(mfrow = c(3,2))
y = c(0,15)
hist(conScores_t[,1],col="red",breaks = 100,xlim=c(-0.5,1),xlab = "Cell Consistency Score",main="t = -1")
hist(conScores_t[,2],col="blue",breaks = 100, xlim=c(-0.5,1),ylim = y,xlab = "Cell Consistency Score",main="t = 0")
hist(conScores_t[,3],col="green",breaks = 100, xlim=c(-0.5,1),ylim = y,xlab = "Cell Consistency Score",main="t = 0.25")
hist(conScores_t[,4],col="yellow",breaks = 100, xlim=c(-0.5,1),ylim = y,xlab = "Cell Consistency Score",main="t = 0.5")
hist(conScores_t[,5],col="black",breaks = 100, xlim=c(-0.5,1),ylim = y,xlab = "Cell Consistency Score",main="t = 0.75")
hist(conScores_t[,6],col="cyan",breaks = 100, xlim=c(-0.5,1),ylim = y,xlab = "Cell Consistency Score",main="t = 0.9")

print("Mean consistency scores")
print(colMeans(conScores_t))
print("Median consistency scores")
print(sapply(c(1:6), function(x) median(conScores_t[,x])))

```


```{r scratch,fig.width=7.5, fig.height=5, eval = FALSE}
#k=1 and k=50 
set.seed(5)
k=1
graphViz(curr.scores.sub,proj.scores.sub,k,"L2","cosine",0.25,cell.cols.sub,paste("K = ",k),plot = TRUE,return_graph = FALSE)
k=50
graphViz(curr.scores.cellsub,proj.scores.cellsub,k,"L2","cosine",0.25,cell.cols.sub,paste("K = ",k),plot = TRUE,return_graph = FALSE)

```
```{r,fig.width=7.5, fig.height=5, eval = FALSE}
#t=-1 and t=0.5
set.seed(1)
t=-1
graphViz(curr.scores.cellsub,proj.scores.sub,10,"L2","cosine",t,cell.cols.sub,paste("",t),plot = TRUE,return_graph = FALSE)
t=0.5
graphViz(curr.scores.cellsub,proj.scores.sub,10,"L2","cosine",t,cell.cols.sub,paste("",t),plot = TRUE,return_graph = FALSE)


```

